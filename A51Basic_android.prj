<?xml version="1.0" encoding="Shift_JIS" ?>
<!-- なんちゃってXML version 0.1( ObjectEditor専用 ) -->
<xobject>
<ID>project</ID>
<x0>0</x0>
<y0>0</y0>
<width>200</width>
<height>100</height>
<ID_maker>27</ID_maker>
<objectname>A51Basic_android</objectname>
<description>新規のアプリケーション</description>
<codeclip>
<ID>_CSTART</ID>
<x0>10</x0>
<y0>10</y0>
<width>80</width>
<height>24</height>
<codetext>Activity ACTIVITY;
</codetext>
</codeclip>
<pin>
<ID>_PSTART</ID>
<x0>12</x0>
<y0>119</y0>
<width>55</width>
<height>24</height>
<text>Start()</text>
<px>50</px>
<py>50</py>
</pin>
<codeclip>
<ID>_C3</ID>
<x0>57</x0>
<y0>266</y0>
<width>350</width>
<height>322</height>
<codetext>// 変数
 A51Basic      a51basic = null;
 Handler       disp_handler = null;
 Paint         paint = null;
 SurfaceView   disp = null;
 SurfaceHolder sufaceHolder = null;
 Thread        thread = null;
 EditText      input = null, edit = null;
 Button        enter_button = null;
 Button        stop_button = null;
 Matrix        matrix = null;
 Bitmap        bitmap = null;
 Canvas        bmp_canvas = null;
 String        InputBuffer=&quot;&quot;;
 boolean      input_flg = false;
 char          GetchChar = &apos;\0&apos;;
 int fontsize = 20;
 int width=640, height=320, posx=0, posy=0;
 int stepx = fontsize+3, stepy = fontsize+3;
boolean prog_mode=false;
Handler handler = new Handler();
</codetext>
</codeclip>
<xobject>
<ID>_X4</ID>
<x0>525</x0>
<y0>62</y0>
<width>210</width>
<height>194</height>
<objectname>Control</objectname>
<description></description>
<operation>
<ID>_O8</ID>
<state1>_SINIT</state1>
<state2>_SINIT</state2>
<x0>400</x0>
<y0>185</y0>
<width>202</width>
<height>57</height>
<inconnectx0>0</inconnectx0>
<inconnecty0>40</inconnecty0>
<outconnectx0>0</outconnectx0>
<outconnecty0>40</outconnecty0>
<inpintext>in( SurfaceView t)</inpintext>
<inpinx0>2</inpinx0>
<inpiny0>33</inpiny0>
<inpinwidth>117</inpinwidth>
<inpinheight>25</inpinheight>
<outpintext>out()</outpintext>
<outpinx0>90</outpinx0>
<outpiny0>40</outpiny0>
<outpinwidth>40</outpinwidth>
<outpinheight>20</outpinheight>
<inpinlinkcount>1</inpinlinkcount>
<description></description>
<codetext>disp = t;
sufaceHolder = disp.getHolder();

</codetext>
</operation>
<operation>
<ID>_O5</ID>
<state1>_SINIT</state1>
<state2>_SINIT</state2>
<x0>394</x0>
<y0>117</y0>
<width>174</width>
<height>56</height>
<inconnectx0>0</inconnectx0>
<inconnecty0>40</inconnecty0>
<outconnectx0>0</outconnectx0>
<outconnecty0>40</outconnecty0>
<inpintext>in(SurfaceHolder h)</inpintext>
<inpinx0>0</inpinx0>
<inpiny0>35</inpiny0>
<inpinwidth>137</inpinwidth>
<inpinheight>19</inpinheight>
<outpintext>out()</outpintext>
<outpinx0>90</outpinx0>
<outpiny0>40</outpiny0>
<outpinwidth>40</outpinwidth>
<outpinheight>20</outpinheight>
<inpinlinkcount>1</inpinlinkcount>
<description></description>
<codetext>// Basicを起動



        sufaceHolder = h;

        bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
        bmp_canvas = new Canvas(bitmap);
        bmp_canvas.drawColor(Color.BLACK);
        
        paint = new Paint();
        paint.setColor(Color.WHITE);
        paint.setStrokeWidth(5.0f);
        paint.setStyle(Style.FILL);
        paint.setAntiAlias(true);
        
        matrix = new Matrix();
        matrix.postTranslate(0, -stepy);
        
        paint.setColor(Color.rgb(for_r, for_g, for_b));






        bmp_canvas.drawLine(posx+3, posy, posx+3, posy+fontsize, paint);
        a51basic = new A51Basic();
        a51basic.startBasic();
</codetext>
</operation>
<pin>
<ID>_P15</ID>
<text>disp_is(SurfaceView t)</text>
<x0>185</x0>
<y0>219</y0>
<width>139</width>
<height>23</height>
<px>10</px>
<py>135</py>
</pin>
<relation>
<ID>_R16</ID>
<pin2name>_O8</pin2name>
<pin1name>_P15</pin1name>
</relation>
<pin>
<ID>_P17</ID>
<text>start(SurfaceHolder h)</text>
<x0>184</x0>
<y0>155</y0>
<width>163</width>
<height>21</height>
<px>9</px>
<py>159</py>
</pin>
<relation>
<ID>_R18</ID>
<pin2name>_O5</pin2name>
<pin1name>_P17</pin1name>
</relation>
<ID_maker>44</ID_maker>
<pin>
<ID>_P22</ID>
<x0>184</x0>
<y0>281</y0>
<width>151</width>
<height>24</height>
<text>input_is(EditText e)</text>
<px>8</px>
<py>58</py>
</pin>
<pin>
<ID>_P23</ID>
<x0>247</x0>
<y0>499</y0>
<width>50</width>
<height>25</height>
<text>enter()</text>
<px>16</px>
<py>84</py>
</pin>
<pin>
<ID>_P24</ID>
<x0>240</x0>
<y0>570</y0>
<width>51</width>
<height>24</height>
<text>stop()</text>
<px>12</px>
<py>110</py>
</pin>
<operation>
<ID>_O25</ID>
<state1>_SINIT</state1>
<state2>_SINIT</state2>
<x0>402</x0>
<y0>282</y0>
<width>118</width>
<height>53</height>
<inconnectx0>0</inconnectx0>
<inconnecty0>40</inconnecty0>
<outconnectx0>0</outconnectx0>
<outconnecty0>40</outconnecty0>
<inpintext>in(EditText e)</inpintext>
<inpinx0>0</inpinx0>
<inpiny0>34</inpiny0>
<inpinwidth>89</inpinwidth>
<inpinheight>19</inpinheight>
<outpintext>out()</outpintext>
<outpinx0>90</outpinx0>
<outpiny0>40</outpiny0>
<outpinwidth>40</outpinwidth>
<outpinheight>20</outpinheight>
<inpinlinkcount>1</inpinlinkcount>
<description></description>
<codetext>input = e;
</codetext>
</operation>
<relation>
<ID>_R26</ID>
<pin1name>_P22</pin1name>
<pin2name>_O25</pin2name>
</relation>
<operation>
<ID>_O29</ID>
<state1>_SINIT</state1>
<state2>_SINIT</state2>
<x0>404</x0>
<y0>466</y0>
<width>306</width>
<height>56</height>
<inconnectx0>0</inconnectx0>
<inconnecty0>40</inconnecty0>
<outconnectx0>0</outconnectx0>
<outconnecty0>40</outconnecty0>
<inpintext>in()</inpintext>
<inpinx0>0</inpinx0>
<inpiny0>35</inpiny0>
<inpinwidth>40</inpinwidth>
<inpinheight>20</inpinheight>
<outpintext>out()</outpintext>
<outpinx0>90</outpinx0>
<outpiny0>40</outpiny0>
<outpinwidth>40</outpinwidth>
<outpinheight>20</outpinheight>
<inpinlinkcount>1</inpinlinkcount>
<description></description>
<codetext>  InputBuffer = ((SpannableStringBuilder)input.getText()).toString() + &quot;\r&quot;;
  input.setText(&quot;&quot;);

</codetext>
</operation>
<relation>
<ID>_R30</ID>
<pin1name>_P23</pin1name>
<pin2name>_O29</pin2name>
</relation>
<operation>
<ID>_O31</ID>
<state1>_SINIT</state1>
<state2>_SINIT</state2>
<x0>410</x0>
<y0>538</y0>
<width>122</width>
<height>52</height>
<inconnectx0>0</inconnectx0>
<inconnecty0>40</inconnecty0>
<outconnectx0>0</outconnectx0>
<outconnecty0>40</outconnecty0>
<inpintext>in()</inpintext>
<inpinx0>0</inpinx0>
<inpiny0>34</inpiny0>
<inpinwidth>40</inpinwidth>
<inpinheight>20</inpinheight>
<outpintext>out()</outpintext>
<outpinx0>90</outpinx0>
<outpiny0>40</outpiny0>
<outpinwidth>40</outpinwidth>
<outpinheight>20</outpinheight>
<inpinlinkcount>1</inpinlinkcount>
<description></description>
<codetext> if(prog_mode){
    disp_prog_mode( false );
 }
 else{
   if( a51basic != null &amp;&amp; a51basic.ThreadBasic != null ) a51basic.ThreadBasic.run_basic = false;
   InputBuffer = &quot;\n&quot;;
 }
</codetext>
</operation>
<relation>
<ID>_R32</ID>
<pin1name>_P24</pin1name>
<pin2name>_O31</pin2name>
</relation>
</xobject>
<codeclip>
<ID>_C5</ID>
<x0>740</x0>
<y0>48</y0>
<width>99</width>
<height>19</height>
<codetext>// 描画関数

// エスケープモード
int ESC_NONE   = 0;
int ESC_START  = 1;
int ESC_SHARP  = 2;
int ESC_LPARM  = 3;
int ESC_RPARM  = 4;
int ESC_BRACKET= 5;
int EscapeMode = ESC_NONE;


    // 実際に画面に表示する
    public void _disp(){
      if( sufaceHolder != null){
        Canvas cv = sufaceHolder.lockCanvas();
        cv.drawBitmap( bitmap, 0, 0, null);
        sufaceHolder.unlockCanvasAndPost(cv);
      }
    }
  
  
    public void disp_cls(){
      paint.setStyle(Paint.Style.FILL);
      paint.setColor(Color.rgb(bak_r,bak_g,bak_b));
      bmp_canvas.drawRect(0, 0, width, height, paint);
      posx=0;
      posy=0;
      paint.setColor(Color.rgb(for_r, for_g, for_b));
      bmp_canvas.drawLine(posx+3, posy, posx+3, posy+fontsize, paint);    
    }


    public void disp_puts( String s ){
      for( int i = 0; i &lt; s.length(); i++ ){
        disp_putc( s.charAt( i ) );
      }
    }

    public void disp_putc( char c ){
      paint.setColor(Color.rgb(bak_r, bak_g, bak_b));
      paint.setStrokeWidth(3);
      bmp_canvas.drawLine(posx+3, posy, posx+3, posy+fontsize, paint);    

      if( EscapeMode==ESC_START){
        if( c == &apos;#&apos; ) EscapeMode = ESC_SHARP;
        else if( c == &apos;(&apos; ) EscapeMode = ESC_LPARM;
        else if( c == &apos;)&apos; ) EscapeMode = ESC_RPARM;
        else if( c == &apos;[&apos; ) EscapeMode = ESC_BRACKET;
        else EscapeMode = ESC_NONE;
        }

      else if( EscapeMode==ESC_SHARP){
        EscapeMode = ESC_NONE;
        }

      else if( EscapeMode==ESC_LPARM){
        EscapeMode = ESC_NONE;
        }

      else if( EscapeMode==ESC_RPARM){
        EscapeMode = ESC_NONE;
        }

      else if( EscapeMode==ESC_BRACKET){
        if( c &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos; ) {}
        else if( c == &apos;;&apos; ) {}
        else{
          EscapeMode = ESC_NONE;
           }
        }

      else{
        if( (byte)c == (byte)0x1b ) EscapeMode = ESC_START;

        else if( c == &apos;\r&apos; ){}
        else if( c == &apos;\n&apos; ){
          posx = 0;
          posy += stepy;
          if( posy &gt;= height-stepy-1 ){
            bmp_canvas.drawBitmap(bitmap, matrix, paint);
            posy -= stepy;
            paint.setStyle(Paint.Style.FILL);
            paint.setColor(Color.rgb(bak_r,bak_g,bak_b));
            bmp_canvas.drawRect(0, posy, width, height, paint);
              }
           }
        else{
          int textwidth;
          if( ( c&lt;=&apos;\u007e&apos; )||
              ( c==&apos;\u00a5&apos; )||
              ( c==&apos;\u203e&apos; )||
              ( c&gt;=&apos;\uff61&apos; &amp;&amp; c&lt;=&apos;\uff9f&apos; )
            )  textwidth = stepx/2+2;
          else textwidth = stepx;
          paint.setStyle(Paint.Style.FILL);
          paint.setColor(Color.rgb(bak_r,bak_g,bak_b));
          bmp_canvas.drawRect(posx, posy, posx+textwidth-1, posy+stepy-1, paint);
          paint.setTypeface(Typeface.create(Typeface.MONOSPACE, Typeface.NORMAL));
          paint.setAntiAlias(false);
          paint.setColor(Color.rgb(for_r,for_g,for_b));
          paint.setTextSize(fontsize);
          bmp_canvas.drawText(c+&quot;&quot;, posx, posy+fontsize, paint);
          posx += textwidth;
          if( posx &gt;= width ){
            posx = 0;
            posy += stepy;
            if( posy &gt;= height-stepy-1 ){
              bmp_canvas.drawBitmap(bitmap, matrix, paint);
              posy -= stepy;
              paint.setStyle(Paint.Style.FILL);
              paint.setColor(Color.rgb(bak_r,bak_g,bak_b));
              bmp_canvas.drawRect(0, posy, width, height, paint);
               }
            }
          }
        }
      paint.setColor(Color.rgb(for_r, for_g, for_b));
      bmp_canvas.drawLine(posx+3, posy, posx+3, posy+fontsize, paint);    
      }


    public void disp_color1( int c ){
      for_r = ( c &gt;&gt; 16 ) &amp; 0xff;
      for_g = ( c &gt;&gt; 8  ) &amp; 0xff;
      for_b = c &amp; 0xff;
    }


    public void disp_color2( int c1, int c2 ){
      for_r = ( c1 &gt;&gt; 16 ) &amp; 0xff;
      for_g = ( c1 &gt;&gt; 8  ) &amp; 0xff;
      for_b = c1 &amp; 0xff;
      bak_r = ( c2 &gt;&gt; 16 ) &amp; 0xff;
      bak_g = ( c2 &gt;&gt; 8  ) &amp; 0xff;
      bak_b = c2 &amp; 0xff;
    }


    public void disp_screen1( int wid, int hei ){
      if( sufaceHolder != null){
        Canvas cv = sufaceHolder.lockCanvas();
        paint.setColor(Color.BLACK);
        paint.setStyle(Style.FILL);
        cv.drawRect(0, 0, disp.getWidth()-1, disp.getHeight()-1, paint);
        sufaceHolder.unlockCanvasAndPost(cv);
     }
      width  = wid;
      height = hei;
      bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
      bmp_canvas = new Canvas(bitmap);
      bmp_canvas.drawColor(Color.BLACK);
      disp_cls();_disp();
    }


    public void disp_screen2( int wid, int hei, int fnt ){
      if( sufaceHolder != null){
        Canvas cv = sufaceHolder.lockCanvas();
        paint.setColor(Color.BLACK);
        paint.setStyle(Style.FILL);
        cv.drawRect(0, 0, disp.getWidth()-1, disp.getHeight()-1, paint);
        sufaceHolder.unlockCanvasAndPost(cv);
      }
      width  = wid;
      height = hei;
      fontsize = fnt;
      stepx = stepy = fontsize + 3;
      matrix = new Matrix();
      matrix.postTranslate(0, -stepy);
      bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
      bmp_canvas = new Canvas(bitmap);
      bmp_canvas.drawColor(Color.BLACK);
      disp_cls();_disp();
    }

    public void disp_locate( int x, int y ){
      paint.setColor(Color.rgb(bak_r, bak_g, bak_b));
      bmp_canvas.drawLine(posx+3, posy, posx+3, posy+fontsize, paint);    
      posx=x * stepx;
      posy=y * stepy;
      paint.setColor(Color.rgb(for_r, for_g, for_b));
      bmp_canvas.drawLine(posx+3, posy, posx+3, posy+fontsize, paint);    
    }

    public void disp_pset( int x, int y ){
      paint.setColor(Color.rgb(for_r, for_g, for_b));
      bmp_canvas.drawPoint(x, y, paint);
    }

    public void disp_line( int x0, int y0, int x1, int y1 ){
      paint.setColor(Color.rgb(for_r, for_g, for_b));
      paint.setStrokeWidth(1);
      bmp_canvas.drawLine(x0, y0, x1, y1, paint);
    }

    public void disp_box( int x0, int y0, int x1, int y1 ){
      paint.setColor(Color.rgb(for_r, for_g, for_b));
      paint.setStyle(Style.STROKE);
      paint.setStrokeWidth(1);
      bmp_canvas.drawRect(x0, y0, x1, y1, paint);
    }


    public void disp_boxf( int x0, int y0, int x1, int y1 ){
      paint.setColor(Color.rgb(for_r, for_g, for_b));
      paint.setStyle(Style.FILL);
      bmp_canvas.drawRect(x0, y0, x1, y1, paint);
    }


    public void disp_circle( int x0, int y0, int x1, int y1 ){
      paint.setColor(Color.rgb(for_r, for_g, for_b));
      paint.setStyle(Style.STROKE);
      paint.setStrokeWidth(1);
      RectF ovalF = new RectF(x0, y0, x1, y1);
      bmp_canvas.drawOval(ovalF, paint);
    }


    public void disp_circlef( int x0, int y0, int x1, int y1 ){
      paint.setColor(Color.rgb(for_r, for_g, for_b));
      paint.setStyle(Style.FILL);
      RectF ovalF = new RectF(x0, y0, x1, y1);
      bmp_canvas.drawOval(ovalF, paint);
    }

    public void disp_image( int x, int y, String file ){
      try{
        FileInputStream in = new FileInputStream(new File(file));
        bmp_canvas.drawBitmap(BitmapFactory.decodeStream( in ), x, y, null);
        in.close();
      }catch(Exception e){}
    }


    public void disp_start( String cmd ){
      Runtime runtime = Runtime.getRuntime();
      try {            //実行するコマンドを指定
        runtime.exec(cmd);
      } catch (IOException e) {} 
    }


    public void disp_exec( String cmd ){
      Runtime runtime = Runtime.getRuntime();
      Process process;
      String  line = &quot;&quot;;
      BufferedReader reader;
      try {            //実行するコマンドを指定
        process = runtime.exec(cmd);
        reader = new BufferedReader( new InputStreamReader(process.getInputStream()));
        while ((line = reader.readLine()) != null) {
          disp_puts( line + &quot;\n&quot; );_disp();
        }
        reader.close();
        process.waitFor();
      } catch (IOException e) {} catch (InterruptedException e) {}
    }


    public String disp_time(){
      String s = (new SimpleDateFormat(&quot;HH:mm:ss&quot; , Locale.US)).format(new Date());
      return s;
    }


    public String disp_date(){
      String s = (new SimpleDateFormat(&quot;yy/MM/dd&quot;, Locale.US)).format(new Date());
      return s;
    }


    /* 1行入力 */
    public String disp_gets(){
      String ret;
      input_flg = true;
      while( InputBuffer.equals(&quot;&quot;) ){
        try{
          Thread.sleep(100, 0);
        }catch( InterruptedException e ){}
      }
      ret = new String( InputBuffer );
      disp_puts( InputBuffer+&quot;\n&quot; );
      InputBuffer = &quot;&quot;;
      input_flg = false;
      return ret;
    }


    // キー入力を調べる
    public char disp_inkey(){
      char ch = GetchChar;
      GetchChar = &apos;\0&apos;;
      if( ch == &apos;\n&apos; ) ch = &apos;\r&apos;;
      return ch;
    }


    // １文字入力
    public char disp_getch(){
      char ch = GetchChar;
      GetchChar = &apos;\0&apos;;
      while( (ch = GetchChar) == &apos;\0&apos; ){
        try{
          Thread.sleep(100, 0);
        }catch( InterruptedException e ){}
      }
      return ch;
    }


    // メディアファイルを再生する
    public void disp_play( String fname ){
      MediaPlayer mp = new MediaPlayer();
      try {
        mp.setDataSource( fname );
        mp.prepare();
      }
      catch (IllegalArgumentException e) {}
      catch (SecurityException e) {}
      catch (IllegalStateException e) {}
      catch (IOException e) {}
      mp.start();
    }

    // モード切り替え
    public void disp_prog_mode( boolean mode ){
      prog_mode = mode;
      handler.post(new Runnable(){
        @Override
        public void run(){
          if( prog_mode ){
a51basic.save_edit();
            edit.bringToFront(); 
            edit.requestFocus();
            edit.setSelection(0); 
              }
          else{
a51basic.load_edit();
            disp.bringToFront(); 
            input.requestFocus(); 
              }
            }
        });
    }



</codetext>
</codeclip>
<relation>
<ID>_R6</ID>
<pin1name>_A0(_PAStopButton)</pin1name>
<pin2name>_X4(_P24)</pin2name>
</relation>
<relation>
<ID>_R7</ID>
<pin1name>_A0(_PAEnterButton)</pin1name>
<pin2name>_X4(_P23)</pin2name>
</relation>
<aobject>
<ID>_A0</ID>
<x0>229</x0>
<y0>60</y0>
<width>284</width>
<objectname>GUI</objectname>
<description>GUIオブジェクト
</description>
<state>
<ID>_SINIT</ID>
<x0>0</x0>
<y0>40</y0>
<width>70</width>
<height>40</height>
<text>  InitState</text>
<isinitstate>1</isinitstate>
</state>
<pin>
<ID>_Pstart</ID>
<x0>400</x0>
<y0>100</y0>
<width>80</width>
<height>26</height>
<text>Start()</text>
<px>0</px>
<py>36</py>
</pin>
<pin>
<ID>_PGUIout</ID>
<x0>0</x0>
<y0>84</y0>
<width>180</width>
<height>26</height>
<text>GUI_created(AbsoluteLayout l)</text>
<px>0</px>
<py>54</py>
</pin>
<action>
<ID>_Astart</ID>
<comp1name>_Pstart</comp1name>
<comp2name>_Ocreate</comp2name>
</action>
<operation>
<ID>_Ocreate</ID>
<state1>_SINIT</state1>
<state2>_SINIT</state2>
<x0>220</x0>
<y0>40</y0>
<width>130</width>
<height>64</height>
<inconnectx0>0</inconnectx0>
<inconnecty0>30</inconnecty0>
<outconnectx0>0</outconnectx0>
<outconnecty0>30</outconnecty0>
<inpintext>in()</inpintext>
<inpinx0>90</inpinx0>
<inpiny0>43</inpiny0>
<inpinwidth>40</inpinwidth>
<inpinheight>20</inpinheight>
<outpintext>out()</outpintext>
<outpinx0>90</outpinx0>
<outpiny0>40</outpiny0>
<outpinwidth>40</outpinwidth>
<outpinheight>20</outpinheight>
<inpinlinkcount>1</inpinlinkcount>
<description></description>
<codetext>// GUIを作成する
XGUI x = new XGUI();

</codetext>
</operation>
<pin>
<ID>_PInput</ID>
<x0>0</x0>
<y0>110</y0>
<width>200</width>
<height>26</height>
<text>Input_created(EditText e)</text>
<px>0</px>
<py>72</py>
</pin>
<pin>
<ID>_PAEnterButton</ID>
<x0>0</x0>
<y0>138</y0>
<width>200</width>
<height>26</height>
<text>EnterButton_clicked()</text>
<px>0</px>
<py>90</py>
</pin>
<pin>
<ID>_PAStopButton</ID>
<x0>0</x0>
<y0>166</y0>
<width>200</width>
<height>26</height>
<text>StopButton_clicked()</text>
<px>2</px>
<py>111</py>
</pin>
<pin>
<ID>_Pdisp</ID>
<x0>0</x0>
<y0>194</y0>
<width>200</width>
<height>26</height>
<text>disp_created(SurfaceView t)</text>
<px>0</px>
<py>126</py>
</pin>
<codeclip>
<ID>_CXSTART</ID>
<x0>0</x0>
<y0>0</y0>
<width>300</width>
<height>26</height>
<codetext> class XGUI{
Input IInput;
 class Input extends EditText{
 Input(){
 super(ACTIVITY);
 setPadding(1, 1, 1, 1);
 setTextSize( (float)input_fontsize ); setTextColor( Color.rgb( 51, 51, 51 ));
 setBackgroundColor( Color.rgb( 220, 220, 220 ));
 setText( &quot;&quot; );


        addTextChangedListener( new TextWatcher() {

    
            @Override
            public void onTextChanged(CharSequence s, int start, int before, int count) {
                // TODO Auto-generated method stub
                 }
         
            @Override
            public void beforeTextChanged(CharSequence s, int start, int count, int after) {
                // TODO Auto-generated method stub
                 }

            @Override
            public void afterTextChanged(Editable s) {
              // TODO Auto-generated method stub
              String str = ((SpannableStringBuilder)input.getText()).toString();
              if( !str.equals(&quot;&quot;) ){
                int pos = input.getSelectionEnd();
                if( pos &gt; 0 ){
                  GetchChar = str.substring( pos-1, pos).charAt(0);
                  if( input_flg ){
                    if( str.charAt( pos-1 ) == &apos;\n&apos; ){
                      InputBuffer = str.substring( 0, pos-1 ) + &quot;\r&quot;;
                      setText(&quot;&quot;);
                             }
                          }
                  else setText(&quot;&quot;);
                       }
                    }  
                 }
            });


 Input_created( this );
}
}
 class xedit extends EditText{
 xedit(){
 super(ACTIVITY);
 setGravity(Gravity.TOP|Gravity.LEFT);
 setPadding(4, 4, 4, 4);
 setTextSize( (float)edit_fontsize ); setTextColor( Color.rgb( 0, 0, 0 ));
 setBackgroundColor( Color.rgb( 255, 255, 255 ));
 setText( &quot;&quot; );
}
}
EnterButton IEnterButton;
 class EnterButton extends Button{
 EnterButton(){
 super(ACTIVITY);
 setGravity(Gravity.CENTER|Gravity.CENTER);
 setPadding(1, 1, 1, 1);
 setTextSize( (float)enter_fontsize ); setTextColor( Color.rgb( 51, 51, 51 ));
 setBackgroundColor( Color.rgb( 192, 192, 192 ));
 setText( &quot;Enter&quot; );
 setOnClickListener(new Button.OnClickListener(){ public void onClick(View v) {EnterButton_clicked();}} );
}
}
StopButton IStopButton;
 class StopButton extends Button{
 StopButton(){
 super(ACTIVITY);
 setGravity(Gravity.CENTER|Gravity.CENTER);
 setPadding(1, 1, 1, 1);
 setTextSize( (float)stop_fontsize ); setTextColor( Color.rgb( 51, 51, 51 ));
 setBackgroundColor( Color.rgb( 192, 192, 192 ));
 setText( &quot;Stop&quot; );
 setOnClickListener(new Button.OnClickListener(){ public void onClick(View v) {StopButton_clicked();}} );
}
}
disp Idisp;
 class disp extends SurfaceView implements SurfaceHolder.Callback{
 private SurfaceHolder holder;

 disp(){
 super(ACTIVITY);
 setPadding(1, 1, 1, 1);
 holder = getHolder();
 holder.addCallback(this);
 disp_created( this );
}

 @Override
  public void surfaceCreated(SurfaceHolder arg0){
    disp_holder_created(arg0);
  }

  @Override
  public void surfaceChanged(SurfaceHolder arg0, int arg1, int arg2, int arg3){

  }
	
  @Override
  public void surfaceDestroyed(SurfaceHolder arg0){

  }
}
 XGUI(){
 AbsoluteLayout layout=new AbsoluteLayout(ACTIVITY);
layout.setBackgroundColor(Color.rgb( 192, 192, 192));
ACTIVITY.setContentView(layout);
ACTIVITY.setTitle(&quot;A51Basic&quot;);

 edit = new xedit();
 edit.setLayoutParams( new AbsoluteLayout.LayoutParams( disp_width,disp_height,disp_x,disp_y ) );
 layout.addView( edit );

 IInput = new Input();
 IInput.setLayoutParams( new AbsoluteLayout.LayoutParams( input_width,input_height,input_x,input_y ) );
 layout.addView( IInput );
 IEnterButton = new EnterButton();
 IEnterButton.setLayoutParams( new AbsoluteLayout.LayoutParams( enter_width,enter_height,enter_x,enter_y ) );
 layout.addView( IEnterButton );
 IStopButton = new StopButton();
 IStopButton.setLayoutParams( new AbsoluteLayout.LayoutParams( stop_width,stop_height,stop_x,stop_y ) );
 layout.addView( IStopButton );
 Idisp = new disp();
 Idisp.setLayoutParams( new AbsoluteLayout.LayoutParams( disp_width,disp_height,disp_x,disp_y ) );
 layout.addView( Idisp );

Idisp.bringToFront(); 
IInput.requestFocus(); 

 GUI_created( layout );
}
}
</codetext>
</codeclip>
<ID_maker>26</ID_maker>
<height>182</height>
<レイアウト>A51Basic
720
529
192
192
192
xxscale=1
TEXTFIELD;Input;null;3;2;547;32;51;51;51;255;255;255;Dialog;12;1;1;1;EditText;
BUTTON;EnterButton;Enter;555;1;80;32;51;51;51;192;192;192;Dialog;12;null;0;0;1;0;1;Button;
BUTTON;StopButton;Stop;639;0;78;34;51;51;51;192;192;192;Dialog;12;null;0;0;1;0;1;Button;
LABEL;disp;null;2;37;716;488;255;255;255;0;0;0;Monospaced;16;null;2;1;1;1;1;TextView;
</レイアウト>
<pin>
<ID>_P24</ID>
<x0>0</x0>
<y0>222</y0>
<width>248</width>
<height>29</height>
<text>disp_holder_created(SurfaceHolder h)</text>
<px>0</px>
<py>144</py>
</pin>
</aobject>
<relation>
<ID>_R12</ID>
<pin1name>_A0(_PInput)</pin1name>
<pin2name>_X4(_P22)</pin2name>
</relation>
<relation>
<ID>_R14</ID>
<pin1name>_A0(_Pdisp)</pin1name>
<pin2name>_X4(_P15)</pin2name>
</relation>
<relation>
<ID>_R16</ID>
<pin1name>_A0(_P24)</pin1name>
<pin2name>_X4(_P17)</pin2name>
</relation>
<codeclip>
<ID>_C17</ID>
<x0>743</x0>
<y0>13</y0>
<width>231</width>
<height>24</height>
<codetext>//A-51Basicインタプリタver 0.3.2


// Basic処理系
class A51Basic{

static final int MAX_DIMENSION    = 16;    // 配列の最大次元
static final int MAX_PROGRAM_SIZE = 16000; // プログラムTEXT領域のバイトサイズ
static final int MAX_TEXT_LENGTH  = 255;   // テキスト行の長さの限界
static final int MAX_STR_LENGTH   = 511;   // 文字列の長さの限界
static final int MAX_FILES        = 10;    // 開くことのできるファイルの最大数
static final int STACK_SIZE       = 64;    // スタックサイズ

static final int VARIABLE         =  1;     // 変数名
static final int COMMAND          =  2;     // コマンド名
static final int FUNCTION         =  3;     // 関数名
static final int NUMBER           =  4;     // 数字表現文字
static final int DELIMIT          =  5;     // 区切り文字
static final int STRING           =  6;     // 文字列
static final int EOL              =  7;     // 行末
static final int LABEL            =  8;     // ラベル

// 終了コード
static final int ERROR            =  0;     // エラー
static final int DONE             =  1;     // 正常終了
static final int TERMINATE        =  2;     // TEXT実行を終了
static final int QUIT             =  3;     // BASICを終了

// ラベルの先頭文字
static final char LABEL_HEADER    = &apos;@&apos;;    // ラベルの先頭文字

// プログラム構造体
class Program{
  Object prev;   // 前の行
  Object next;   // 次の行
  int    lineno; // 行番号
  int    label;  // ラベルのチェックサム
  String text;   // テキスト先頭文字

  Program(){
    lineno = -1;
    label = -1;
    text = &quot;&quot;;
    prev = null;
    next = null;
  }

  Program( int lin, String txt, int l, Program p, Program n ){
    lineno = lin;
    label = l;
    text = new String(txt);
    prev = p;
    next = n;
  }
}


// 値
class Value{
  int type;
  double number;
  String string;

  Value(){
    type = NUMBER;
    number = 0;
    string = null;
  }
}


// 変数
class Variable{
  String name;       // 変数名
  int    dimension;  // 配列ならば0より大きな数値が入る 
  int[]  dim;
  Object array;
  int    index;
  Value  value;
  Object next;

  Variable(){
    name = null;
    dimension = 0;
    dim = new int[MAX_DIMENSION];
    index = 0;
    array = null;
    value = null;
    next = null;
  }
}


// FOR文用データ
class  FORSF{
  Variable  var;     // ループ変数へのポインタ
  double    limit;   // ループ変数上限値
  double    step;    // STEP値
  Program   program; // リピートTEXT行記憶用
  int       token_p; // リピート有効文字先頭

  FORSF(){
    var = null;
    limit = step = 0;
    program = null;
    token_p = 0;
  }
}


// GOSUB文用データ
class  GOSUBSF{
  Program program;  // リターンする行記憶用
  int     token_p;  // リターンする文字先頭

  GOSUBSF(){
    program = null;
    token_p = 0;
  }
}


// Basic用ファイルディスクリプタ
class XFD{
  Socket sock;
  InputStream    in0;
  OutputStream   out0;
  BufferedReader in;
  BufferedWriter out;

  XFD(){
    sock = null;
    in = null;
    out = null;
  }
}
 

// コマンド
String Command[] ={
  &quot;run&quot;,
  &quot;let&quot;,
  &quot;list&quot;,
  &quot;print&quot;,
  &quot;?&quot;,
  &quot;end&quot;,
  &quot;input&quot;,
  &quot;goto&quot;,
  &quot;for&quot;,
  &quot;next&quot;,
  &quot;gosub&quot;,
  &quot;return&quot;,
  &quot;if&quot;,
  &quot;save&quot;,
  &quot;edit&quot;,
  &quot;load&quot;,
  &quot;new&quot;,
  &quot;clear&quot;,
  &quot;pset&quot;,
  &quot;cls&quot;,
  &quot;line&quot;,
  &quot;locate&quot;,
  &quot;bye&quot;,
  &quot;dim&quot;,
  &quot;open&quot;,
  &quot;close&quot;,
  &quot;box&quot;,
  &quot;boxf&quot;,
  &quot;circle&quot;,
  &quot;circlef&quot;,
  &quot;start&quot;,
  &quot;exec&quot;,
  &quot;wait&quot;,
  &quot;image&quot;,
  &quot;color&quot;,
  &quot;screen&quot;,
  &quot;play&quot;,
  &quot;send&quot;
};

 // 関数
String Function[] ={
  &quot;int&quot;,
  &quot;abs&quot;,
  &quot;sqr&quot;, 
  &quot;exp&quot;, 
  &quot;log&quot;, 
  &quot;sin&quot;, 
  &quot;cos&quot;, 
  &quot;tan&quot;, 
  &quot;atn&quot;, 
  &quot;chr$&quot;, 
  &quot;asc&quot;, 
  &quot;mid$&quot;, 
  &quot;left$&quot;, 
  &quot;right$&quot;, 
  &quot;input$&quot;, 
  &quot;inkey$&quot;, 
  &quot;eof&quot;, 
  &quot;str$&quot;, 
  &quot;val&quot;, 
  &quot;len&quot;, 
  &quot;time$&quot;, 
  &quot;date$&quot;, 
  &quot;instr&quot;, 
  &quot;rnd&quot;, 
  &quot;netstat&quot;,
  &quot;recv&quot; 
};


Program      Prog;
Program      TopProg = null;      // BASICプログラム最初の行と最後の行
Program      EndProg = null;      // BASICプログラム最初の行と最後の行
Program      CurrentProg= null;   // 現在実行中への行へのポインタ
StringBuffer TokenText;           // トークンバッファ
int          TokenP;              // トークン解析用の文字位置ポインタ
int          TokenType,TokenCode; // トークンタイプとコード
double       TokenValue;          // トークンの値
int          SysError = 0;        // この変数がセットされたらシステムエラー
Variable     TopVar = null;       // 変数リスト開始値
Variable     EndVar = null;       // 変数リスト終値
String       Pbuf;
String       ErrorMessage = &quot;&quot;;
String       SyntaxError  = &quot;Syntax Error&quot;;
String       TypeMismatch = &quot;Type Mismatch&quot;;
String       OutOfRange   = &quot;Out of Range&quot;;
char         KeyCode=&apos;\0&apos;;
int          Status;
int          CurrentLineNo;
int          xx0, yy0;
XFD[]        Xfd;    // BASICで使うファイルのハンドル


// 各種スタック
Value[]      CalcStack;   // 演算用
int          CalcStackP;
GOSUBSF[]    GosubStack;  // gosub文用
int          GosubStackP;
FORSF[]      ForStack;    // for文用
int          ForStackP;
int          NetStat;

BasicThread  ThreadBasic = null;

String       Fname0 = null;
boolean      is_first = true;


/* ------------------------------------------ ここからBASIC制御用関数------------------------------------- */

// Basicのエラー
class BasicError extends Exception {
  public String errMsg;
  BasicError(String msg){errMsg =msg;}
}


// エラーを発生させる
public void assertError( String mesg ) throws BasicError{
  disp_puts( mesg );_disp();
  if( CurrentProg != null &amp;&amp; CurrentProg.lineno &gt; 0){
    disp_puts( &quot; in line &quot;+ CurrentProg.lineno );_disp();
  }
  disp_puts( &quot;\n&quot; );_disp();
  BasicError e = new BasicError( mesg );
  throw e;
}


//エラーからの回復
public void resumeError(){
  CalcStack = new Value[STACK_SIZE];
  GosubStack = new GOSUBSF[STACK_SIZE];
  ForStack = new FORSF[STACK_SIZE];
  Prog = new Program();
  CurrentProg = null;
  ThreadBasic = new BasicThread();
  System.gc();
  ThreadBasic.run_basic = true;
  ThreadBasic.start();
}


// Basicを起動する
public void startBasic(){
  is_first = true;
  Intent intent = ACTIVITY.getIntent();
  Uri uri = intent.getData();
  if( uri == null )  Fname0 = intent.getStringExtra(&quot;PATH&quot;);
  else { Fname0= uri.toString().substring(7);}
  CalcStack = new Value[STACK_SIZE];
  GosubStack = new GOSUBSF[STACK_SIZE];
  ForStack = new FORSF[STACK_SIZE];
  Xfd = new XFD[MAX_FILES]; for( int i = 0; i &lt; MAX_FILES; i++ ) Xfd[i] = new XFD();
  Prog = new Program();
  ThreadBasic = new BasicThread();
  ThreadBasic.cmd_new();
  System.gc();
  ThreadBasic.run_basic = true;
  disp_screen2( width,height,fontsize);
  disp_cls();_disp();
  ThreadBasic.start();
}



// Basicのメインスレッド
class BasicThread extends Thread{
  boolean run_basic = true;

  public void run(){

    if( Fname0 != null ){
      if( !is_first ) System.exit(0);
      is_first = false;
      try{
        load_basic( Fname0 );
        run_basic( TopProg );
        System.exit(0);
      } catch( BasicError e ){ System.exit(0); }
    }

    if( is_first ){
      disp_puts( &quot;A-51 Basic for android\n&quot; );_disp();
      disp_puts( &quot;version 0.3.2 \n&quot; );_disp();
    }
    is_first = false;

    Prog = new Program();

    // 通常処理
    disp_puts( &quot;READY\n&quot; );_disp();

    // コマンド入力ループ
    try{
      while( run_basic ){

        // 計算スタック初期化
        clear_value();

        // 1行入力
        Pbuf = disp_gets();_disp();
        if( !run_basic )  break;

        // インタープリタに解析実行させる
        if( !Pbuf.equals(&quot;\r&quot;) ){
          Prog.text = Pbuf;
          Status = run_basic( Prog );
          if( Status != 0 ){
             if( Status == QUIT ){
              cmd_new();
              disp_puts(&quot;&lt;&lt; BYE &gt;&gt;\n&quot; );_disp();
              System.exit(0);
              return;
            }
            if( Status != TERMINATE ) assertError(&quot;ダイレクト実行できません&quot;);
          }
          disp_puts(&quot;\nREADY\n&quot; );_disp();
        }
      }
      if( !run_basic ) assertError(&quot;Break&quot;);
    } catch( BasicError e ){ resumeError(); }
  }


/* ------------------------------------------ ここからBASICプログラム編集用の関数------------------------------------- */


// プログラムを消去する
void clear_program(){
  TopProg = EndProg = null;
}


// 指定されたラベルの位置を返す。ラベルが見つからないときはNULLを返す
Program serch_label_position( int lbl, StringBuffer buf ){
  Program p = TopProg;
  String s = new String(buf);
  String b;
  int i, j, l;

//disp_puts(&quot;serch_label_pos: check=&quot;+lbl+&quot; str=&quot;+buf+&quot;\n&quot;);_disp();

  while( p != null ){
    if( p.label == lbl ){
      b = p.text;
      l = b.length();
      for( i = 0; i &lt; l &amp;&amp; isspace(b.charAt(i)); i++ ) ;
      if( i &lt; l &amp;&amp; b.charAt(i) == LABEL_HEADER ){
        for( j = ++i; j &lt; l &amp;&amp; (isalnum(b.charAt(j)) || b.charAt(j) == &apos;_&apos;); j++ ) ;
        if( b.substring(i,j).equals(s) ) return p;
        }
      }
    p = (Program)p.next;
  }
  return null;
}


// Basicプログラムをロードする
void load_basic( String fname ) throws BasicError{
  String line;
  int lbl;
  Program prog = new Program();

  cmd_new();
  CurrentLineNo = 1;
  try{
    BufferedReader din = new BufferedReader( new FileReader( fname ) );
    while( ( line = din.readLine() ) != null ){
      lbl = checkSum( line );

      if( TopProg == null ){  // プログラムが空の場合
        TopProg = EndProg = new Program( CurrentLineNo++, line+&quot;\r&quot;, lbl, null, null );
        }
      else{
        prog = new Program( CurrentLineNo++, line+&quot;\r&quot;, lbl, EndProg, null );
        EndProg.next = prog;
        EndProg = prog;
       }
     }
    din.close();
  } catch( IOException ie ){ assertError(&quot;ファイル\&quot;&quot; + fname + &quot;\&quot;がロードできません&quot; ); }
}


// プログラムを実行する
int run_basic( Program prog ) throws BasicError{
  int status;

//disp_puts(&quot;run_basic()\n&quot;);_disp();

  clear_value();
  CurrentProg = prog;
  TokenP = 0;
  getToken(); // 最初のトークン切り出し
  while( run_basic ){

//Log.d(&quot;run_basic&quot;, &quot;TokenText=&quot;+TokenText+&quot;, Token Type=&quot;+TokenType+&quot; , Code=&quot;+TokenCode);

    // トークンがCOMMANDなら次のトークンをとりだしてDISPATCH
    if( TokenType == COMMAND ){
      int code = TokenCode;
      getToken();
      status = doBasicCommand( code );
      if( status != DONE ) return status;
    }

    /* トークンが変数なら代入 */
    else if( TokenType == VARIABLE ){
      cmd_let();
    }

    /* トークンがEOLなら次の行へ */
    else if( TokenType == EOL ){

      // 次の行に移る
      CurrentProg = (Program)CurrentProg.next;

      // 最終行(中身無し)に到達すると終了
      if( CurrentProg == null ) return TERMINATE;

      // テキストポインタを設定
      TokenP = 0;
      getToken();
    }

    /* マルチステートメントの処理 */
    else if( TokenType == DELIMIT ){
      if( TokenType == DELIMIT &amp;&amp; TokenText.charAt(0) == &apos;:&apos; ) getToken(); else assertError( SyntaxError );
    }

    // ラベルの場合は無視(1つの行に2個以上ラベルがある場合は、最初のラベル以外は無視されるので注意)
    else if( TokenType == LABEL ){
      getToken();
    }

    /* 上に当てはまらないなら文法エラー*/  
    else assertError( SyntaxError );
  }
  return 0;
}


/* トークンが正しければ次のトークンを読み込み、トークンが間違っていたらエラーを発生させる */
void checkToken( String token ) throws BasicError{
  if( !TokenText.toString().equals(token) ) assertError( SyntaxError );
  getToken();
}


/* トークンを切り出してバッファに格納する    */
void getToken() throws BasicError{
  int    t;
  char   c =&apos;\0&apos;;

//Log.d(&quot;getToken(ENTER)&quot;, &quot;Text=&quot;+CurrentProg.text);


 try{

  TokenText = new StringBuffer(&quot;&quot;);

  // 空白や制御文字をスキップする
  while( ( c = CurrentProg.text.charAt(TokenP) ) &lt;= &apos; &apos; ){

    // &apos;\n&apos;は行の終わり
    if( TokenP &gt;= CurrentProg.text.length()-1 ){
      TokenType = EOL;
      return;
    }

    TokenP++;
  }

  // &quot;&apos;&quot;が現れたときは行の終わり
  if( ( c = CurrentProg.text.charAt(TokenP) ) == &apos;\&apos;&apos; ){
    TokenType = EOL;
    return;
  }

  // 先頭が&quot;であれば次の&quot;までは文字列
  else if( c == &apos;\&quot;&apos; ){
    TokenType = STRING;
    TokenP++;
    while( TokenP &lt; CurrentProg.text.length() &amp;&amp; ( c = CurrentProg.text.charAt(TokenP) ) != &apos;\&quot;&apos; ){ TokenText.append(c); TokenP++;}
    if( TokenP &gt;= CurrentProg.text.length() ) assertError(&quot;文字列が不正です&quot;);
    TokenP++;

//Log.d(&quot;getToken(STR)&quot;, &quot;TokenText=\&quot;&quot;+TokenText+&quot;\&quot;&quot;);

    return;
  }

  // 先頭がアルファベット
  else if( isalpha( c ) || c == &apos;?&apos; || c == &apos;_&apos; ){
    while( isalnum( c = CurrentProg.text.charAt(TokenP) ) || c == &apos;_&apos; || c == &apos;$&apos; ){
      TokenText.append(c);
      TokenP++;
    }

    // Basicのコマンドの場合
    for( t = 0; t &lt; Command.length; t++ ){
      if( Command[ t ].equals( TokenText.toString() ) ){
        TokenType = COMMAND;
        TokenCode = t;
 
//Log.d(&quot;getToken(CMD)&quot;, &quot;TokenText=&quot;+TokenText+&quot;, Token Type=&quot;+TokenType+&quot;, Code=&quot;+TokenCode);

        return;
      }
    }

    // 関数の場合
    for( t = 0; t &lt;Function.length; t++ ){
      if( Function[ t ].equals( TokenText.toString() ) ){
        TokenType = FUNCTION;
        TokenCode = t;

//Log.d(&quot;getToken(FUNC)&quot;, &quot;TokenText=&quot;+TokenText+&quot;, Token Type=&quot;+TokenType+&quot;, Code=&quot;+TokenCode);

        return;
      }
    }

    // コマンドでも関数でもないときは変数とみなす
    TokenType = VARIABLE;
    return;
  }

  // 先頭がラベルの先頭文字であれば英数字と&apos;_&apos;が続いているところはラベル
  else if( c == LABEL_HEADER ){
    TokenType = LABEL;
    TokenP++;
    TokenCode = 0;
    while( isalnum( c = CurrentProg.text.charAt(TokenP) ) || c == &apos;_&apos; ){
      TokenText.append(c);
      TokenCode += (int)(byte)c;
      TokenP++;
    }
  }

  /* 先頭が&apos;&amp;&apos;で始まっている場合が数値 */
  else if( c == &apos;&amp;&apos; ){
    TokenType = NUMBER;
    if( ++TokenP &gt;= CurrentProg.text.length() ) assertError(&quot;数値表記が不正です&quot;);

    // 16進数
    if( (c = CurrentProg.text.charAt(TokenP)) == &apos;h&apos; || c == &apos;H&apos; ){
      if( ++TokenP &gt;= CurrentProg.text.length() ) assertError(&quot;16進数の表記が不正です&quot;);
      if( ( ( c = CurrentProg.text.charAt(TokenP) ) &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos; ) || ( c &gt;= &apos;a&apos; &amp;&amp; c &lt;= &apos;f&apos; ) || ( c &gt;= &apos;A&apos; &amp;&amp; c &lt;= &apos;F&apos; ) ){
        do {
          TokenText.append(c);
          if( ++TokenP &gt;= CurrentProg.text.length() ){
            TokenValue = (double)Integer.parseInt( TokenText.toString(), 16 );
            return;
          }
          c = CurrentProg.text.charAt(TokenP);
        } while( ( c &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos; ) || ( c &gt;= &apos;a&apos; &amp;&amp; c &lt;= &apos;f&apos; ) || ( c &gt;= &apos;A&apos; &amp;&amp; c &lt;= &apos;F&apos; ) );
        TokenValue = (double)Integer.parseInt( TokenText.toString(), 16 );
        return;
      }
      assertError(&quot;16進数の表記が不正です&quot;);
    }

    // 8進数
    else{
      if( c &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;7&apos; ){
        do {
          TokenText.append(c);
          if( ++TokenP &gt;= CurrentProg.text.length() ){
            TokenValue = (double)Integer.parseInt( TokenText.toString(), 8 );
            return;
          }
          c = CurrentProg.text.charAt(TokenP);
        } while( c &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;7&apos; );
        TokenValue = (double)Integer.parseInt( TokenText.toString(), 8 );
        return;
      }
      assertError(&quot;8進数の表記が不正です&quot;);
    }
  }

  // 先頭が&apos;.&apos;で始まっている場合も数値
  else if( c == &apos;.&apos; ){
    TokenType = NUMBER;
    TokenText.append(c);
    if( ++TokenP &gt;= CurrentProg.text.length() ) assertError(&quot;数値表記が不正です&quot;);
    if( ( c = CurrentProg.text.charAt(TokenP) ) &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos; ){
      do {
        TokenText.append(c);
        if( ++TokenP &gt;= CurrentProg.text.length() ){
          TokenValue = Double.parseDouble( TokenText.toString() );
          return;
        }
        c = CurrentProg.text.charAt(TokenP);
      } while( &apos;0&apos; &lt;= c &amp;&amp; c &lt;= &apos;9&apos; );
      // 実数(指数表示)
      if( c == &apos;e&apos; || c == &apos;E&apos; ){
        TokenText.append(c);
        if( ++TokenP &gt;= CurrentProg.text.length() ) assertError(&quot;数値表記が不正です&quot;);
        if( ( c = CurrentProg.text.charAt(TokenP) ) == &apos;+&apos; || c == &apos;-&apos; ){
          TokenText.append(c);
          if( ++TokenP &gt;= CurrentProg.text.length() ) assertError(&quot;数値表記が不正です&quot;);
        }
        if( ( c = CurrentProg.text.charAt(TokenP) ) &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos; ){
          do {
            TokenText.append(c);
            if( ++TokenP &gt;= CurrentProg.text.length() ){
              TokenValue = Double.parseDouble( TokenText.toString() );
              return;
            }
            c = CurrentProg.text.charAt(TokenP);
          } while( c &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos; );
          TokenValue = Double.parseDouble( TokenText.toString() );
          return;
        }
        assertError(&quot;数値表記が不正です&quot;);
      }
      // 単純な小数
      else{
        TokenValue = Double.parseDouble( TokenText.toString() );
        return;
      }
    }
    assertError(&quot;数値表記が不正です&quot;);
  }

  // 先頭が数字で始まっている場合も数値
  else if( c &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos; ){
    TokenType = NUMBER;
    do {
      TokenText.append(c);
      if( ++TokenP &gt;= CurrentProg.text.length() ){
        TokenValue = Double.parseDouble( TokenText.toString() );
        return;
      }
      c = CurrentProg.text.charAt(TokenP);
    } while( &apos;0&apos; &lt;= c &amp;&amp; c &lt;= &apos;9&apos; );

    if( c == &apos;.&apos; ){
      TokenType = NUMBER;
      TokenText.append(c);
      if( ++TokenP &gt;= CurrentProg.text.length() ){
        TokenValue = Double.parseDouble( TokenText.toString() );
        return;
      }
      if( ( c = CurrentProg.text.charAt(TokenP) ) &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos; ){
        do {
          TokenText.append(c);
          if( ++TokenP &gt;= CurrentProg.text.length() ){
            TokenValue = Double.parseDouble( TokenText.toString() );
            return;
          }
          c = CurrentProg.text.charAt(TokenP);
        } while( &apos;0&apos; &lt;= c &amp;&amp; c &lt;= &apos;9&apos; );

        // 実数(指数表示)
        if( c == &apos;e&apos; || c == &apos;E&apos; ){
          TokenText.append(c);
          if( ++TokenP &gt;= CurrentProg.text.length() ) assertError(&quot;数値表記が不正です&quot;);
          if( ( c = CurrentProg.text.charAt(TokenP) ) == &apos;+&apos; || c == &apos;-&apos; ){
            TokenText.append(c);
            if( ++TokenP &gt;= CurrentProg.text.length() ) assertError(&quot;数値表記が不正です&quot;);
          }
          if( ( c = CurrentProg.text.charAt(TokenP) ) &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos; ){
            do {
              TokenText.append(c);
              if( ++TokenP &gt;= CurrentProg.text.length() ){
                TokenValue = Double.parseDouble( TokenText.toString() );
                return;
              }
              c = CurrentProg.text.charAt(TokenP);
            } while( c &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos; );
            TokenValue = Double.parseDouble( TokenText.toString() );
            return;
          }
          assertError(&quot;数値表記が不正です&quot;);
        }
        // 単純な小数
        else{
          TokenValue = Double.parseDouble( TokenText.toString() );
          return;
        }
      }
      assertError(&quot;数値表記が不正です&quot;);
    }

    else{

      // 実数(指数表示)
      if( c == &apos;e&apos; || c == &apos;E&apos; ){
        TokenText.append(c);
        if( ++TokenP &gt;= CurrentProg.text.length() ) assertError(&quot;数値表記が不正です&quot;);
        if( ( c = CurrentProg.text.charAt(TokenP) ) == &apos;+&apos; || c == &apos;-&apos; ){
          TokenText.append(c);
          if( ++TokenP &gt;= CurrentProg.text.length() ) assertError(&quot;数値表記が不正です&quot;);
        }
        if( ( c = CurrentProg.text.charAt(TokenP) ) &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos; ){
          do {
            TokenText.append(c);
            if( ++TokenP &gt;= CurrentProg.text.length() ){
              TokenValue = Double.parseDouble( TokenText.toString() );
              return;
            }
            c = CurrentProg.text.charAt(TokenP);
          } while( c &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos; );
          TokenValue = Double.parseDouble( TokenText.toString() );
          return;
        }
        assertError(&quot;数値表記が不正です&quot;);
      }

      //単純な整数表現
      else{
        TokenValue = Double.parseDouble( TokenText.toString() );
        return;
      }
    }

  }

  /* 上記以外は区切り文字 */
  else{
    TokenType = DELIMIT;
    TokenText.append(c);
    TokenP++;

    // 2文字の比較演算子の場合
    if( c == &apos;&lt;&apos; ){
      if( ( c = CurrentProg.text.charAt(TokenP) )  ==&apos;&gt;&apos; || c == &apos;=&apos; ){
        TokenText.append(c);
        TokenP++;
      }
    }
    else if( c == &apos;&gt;&apos; ){
      if( ( c = CurrentProg.text.charAt(TokenP) )  == &apos;=&apos; ){
        TokenText.append(c);
        TokenP++;
      }
    }
  }
  }
  catch( Exception e ){ assertError( SyntaxError ); }
}


/* ------------------------------------------ ここからBASICの組込みコマンド処理用関数　------------------------------------- */
int doBasicCommand( int cmd ) throws BasicError{

//disp_puts(&quot;doBasicCommand: TokenText=&quot;+TokenText+&quot;, Token Type=&quot;+TokenType+&quot; , Code=&quot;+TokenCode);_disp();


  switch( cmd ){
  case  0: return cmd_run();
  case  1: return cmd_let();
  case  2: return cmd_list();
  case  3: return cmd_print();
  case  4: return cmd_print();
  case  5: return cmd_end();
  case  6: return cmd_input();
  case  7: return cmd_goto();
  case  8: return cmd_for();
  case  9: return cmd_next();
  case 10: return cmd_gosub();
  case 11: return cmd_return();
  case 12: return cmd_if();
  case 13: return cmd_save();
  case 14: return cmd_edit();
  case 15: return cmd_load();
  case 16: return cmd_new();
  case 17: return cmd_clear();
  case 18: return cmd_pset();
  case 19: return cmd_cls();
  case 20: return cmd_line();
  case 21: return cmd_locate();
  case 22: return cmd_quit();
  case 23: return cmd_dim();
  case 24: return cmd_open();
  case 25: return cmd_close();
  case 26: return cmd_box();
  case 27: return cmd_boxf();
  case 28: return cmd_circle();
  case 29: return cmd_circlef();
  case 30: return cmd_start();
  case 31: return cmd_exec();
  case 32: return cmd_wait();
  case 33: return cmd_image();
  case 34: return cmd_color();
  case 35: return cmd_screen();
  case 36: return cmd_play();
  case 37: return cmd_send();
  }
  return ERROR;
}


// NEWコマンド
int cmd_new(){
  clear_program(); 
  cmd_clear(); 
  return TERMINATE;
}


// ENDコマンド
int cmd_end() {
  return TERMINATE;
}


// QUITコマンド
int cmd_quit(){
  return QUIT;
}


// listコマンド
int cmd_list() throws BasicError{
  Program p;

//Log.d(&quot;cmd_list&quot;, &quot;TokenText=&quot;+TokenText+&quot;, Token Type=&quot;+TokenType+&quot; , Code=&quot;+TokenCode);

  int st = 0, ed = 0x7fffffff;
  if( TokenType == NUMBER ){
    st = (int)get_number();
    getToken();
  }


//Log.d(&quot;cmd_list&quot;, &quot;TokenText=&quot;+TokenText+&quot;, Token Type=&quot;+TokenType);

  if( TokenType == DELIMIT &amp;&amp; ( TokenText.charAt(0) == &apos;,&apos; || TokenText.charAt(0) == &apos;-&apos; ) ) getToken();
  if( TokenType == NUMBER ){
    ed = (int)get_number();
    getToken();
  }
  for( p = TopProg; p != null; p = (Program)p.next ){
    if( p.lineno &gt;= st &amp;&amp; p.lineno &lt;= ed ){
      disp_puts( p.lineno + &quot; &quot; + p.text + &quot;\n&quot; );_disp();

//      disp_puts( p.lineno + &quot; (&quot; +p.label+&quot;) &quot;+ p.text + &quot;\n&quot; );_disp();

    }
  }
  return TERMINATE;
}


// loadコマンド
int cmd_load() throws BasicError{
  if( TokenType != STRING ) assertError( SyntaxError );
  load_basic( TokenText.toString() );
  return TERMINATE;
}


// saveコマンド
int cmd_save() throws BasicError{
  Program p;
  if( TokenType != STRING ) assertError( SyntaxError );
  String fname = TokenText.toString();
  try{
    BufferedWriter dout = new BufferedWriter( new FileWriter( fname ) );
    for( p = TopProg; p != null; p = (Program)p.next ){
      String txt = p.text;
      dout.write( txt.substring(0,txt.length()-1) + &quot;\n&quot;);
    }
    dout.close();
  } catch( IOException ie ){ assertError(&quot;ファイル\&quot;&quot; + fname + &quot;\&quot;がセーブできません&quot; ); }
  return TERMINATE;
}


// editコマンド
int cmd_edit(){
  disp_prog_mode( true );
  return TERMINATE;
}


// 代入文
int cmd_let() throws BasicError{

//Log.d(&quot;cmd_let&quot;, &quot;TokenText=&quot;+TokenText+&quot;, Token Type=&quot;+TokenType+&quot; , Code=&quot;+TokenCode);

  if( TokenType == VARIABLE ){
    Variable var = _variable( TokenText.toString() );
    Value val = get_variable_value( var );
    checkToken(&quot;=&quot;);
    eval_expression();
    if( val.type != value_type() ) assertError( TypeMismatch );
    if( var.dimension &gt; 0 ){
      if( val.type == STRING ){
        String[] array = (String[])var.array;
        array[ var.index ]  = new String( get_string() );
      }
      else{
        double[] array = (double[])var.array;
        array[ var.index ]  = get_number();
      }
    }
    else{
      if( val.type == STRING ) val.string = new String( get_string() );
      else val.number = get_number();
    }
  }
  return DONE;
}


// runコマンド
int cmd_run() throws BasicError{

//disp_puts( &quot;cmd_run: TokenText=&quot;+TokenText+&quot;, Token Type=&quot;+TokenType+&quot; , Code=&quot;+TokenCode+&quot;\n&quot;);
//_disp();
  int i;

    for( i = 0; i &lt; MAX_FILES; i++ ){
      try{
        if( Xfd[i].sock != null ){
          Xfd[i].sock.close();
          Xfd[i].sock = null;
          Xfd[i].in = null;
          Xfd[i].out = null;
           }
        else{
          if( Xfd[i].in != null ){
            Xfd[i].in.close();
            Xfd[i].in = null;
              }
          if( Xfd[i].out != null ){
            Xfd[i].out.close();
            Xfd[i].out = null;
              }
           }
      } catch( Exception e){ assertError(&quot;i/o error&quot;); }
      }


 cmd_clear();     // 変数をクリア
 ForStackP   = 0; // FOR-NEXT用スタックをクリア
 GosubStackP = 0; // GOSUB-RETURN用スタックをクリア
 if( (CurrentProg = TopProg) == null ) return TERMINATE;
 TokenP = 0;
 getToken();
 return DONE;
}


// printコマンド
int cmd_print() throws BasicError{
  int k;
  String last_token = &quot;&quot;;

//Log.d(&quot;cmd_print(ENTER)&quot;, &quot;TokenText=&quot;+TokenText+&quot;, Token Type=&quot;+TokenType+&quot; , Code=&quot;+TokenCode);

  // print#文
  if( TokenType == DELIMIT &amp;&amp; TokenText.charAt(0) == &apos;#&apos;){
    getToken();
    if( TokenType != NUMBER ) assertError( SyntaxError );
    k = (int)TokenValue;
    if( k &lt; 0 || k &gt;= MAX_FILES ) assertError(OutOfRange );

      // ファイルの場合
    if( Xfd[k].out == null ) assertError(&quot;ファイルが開いていません(print#)&quot;);
    getToken();
    if( TokenType == EOL || ( TokenType == DELIMIT &amp;&amp; TokenText.charAt(0) ==&apos;:&apos; ) ) return DONE;
    checkToken(&quot;,&quot;);
    try{
      while( TokenType != EOL &amp;&amp; !( TokenType == DELIMIT &amp;&amp; TokenText.charAt(0) == &apos;:&apos; ) ){

        // データの表示
        last_token = TokenText.toString();
        clear_value();
        eval_expression();

        // 文字列型データの表示
        if( value_type() == STRING ) Xfd[k].out.write( get_string() );

        // 数値型データの表示
        else{
          Xfd[k].out.write( xstr(get_number()) );
            }
        check_value();

        // セパレータが&apos;,&apos;の場合
        if( TokenType == DELIMIT &amp;&amp; TokenText.charAt(0) ==&apos;,&apos; ){
          last_token = TokenText.toString();
          Xfd[k].out.write( &quot;,&quot; );
          getToken();
        }

        // セパレータが&apos;;&apos;の場合
        else if( TokenType == DELIMIT &amp;&amp; TokenText.charAt(0) ==&apos;;&apos; ){
          last_token = TokenText.toString();
          getToken();
        }
        else if( ( TokenType == DELIMIT &amp;&amp; TokenText.charAt(0)  == &apos;:&apos; ) || TokenType == EOL ) break;
        else assertError( SyntaxError );

      }
      if( !last_token.startsWith(&quot;;&quot;) ) Xfd[k].out.write( &quot;\n&quot; );

    } catch( IOException ie ){ assertError(&quot;i/o error&quot; ); }
   }

  // print文
  else{
    while( !( TokenType == DELIMIT &amp;&amp; TokenText.charAt(0)  == &apos;:&apos; ) &amp;&amp; TokenType != EOL ){

      // データの表示
      last_token = TokenText.toString();
      clear_value();
      eval_expression();

      // 文字列型データの表示
      if( value_type() == STRING ){ disp_puts( get_string() );_disp(); }

      // 数値型データの表示
      else{
        disp_puts( xstr(get_number()) );_disp();
      }
      check_value();

      // セパレータが&apos;,&apos;の場合
      if( TokenType == DELIMIT &amp;&amp; TokenText.charAt(0) ==&apos;,&apos; ){
        last_token = TokenText.toString();
        disp_puts( &quot;,&quot; );_disp();
        getToken();
      }

      // セパレータが&apos;;&apos;の場合
      else if( TokenType == DELIMIT &amp;&amp; TokenText.charAt(0) ==&apos;;&apos; ){
        last_token = TokenText.toString();
        getToken();
      }
      else if( ( TokenType == DELIMIT &amp;&amp; TokenText.charAt(0)  == &apos;:&apos; ) || TokenType == EOL ) break;
      else assertError( SyntaxError );

    }
    if( !last_token.startsWith(&quot;;&quot;) ){ disp_puts( &quot;\n&quot; );_disp(); }
  }

//Log.d(&quot;cmd_print(END)&quot;, &quot;TokenText=&quot;+TokenText+&quot;, Token Type=&quot;+TokenType+&quot; , Code=&quot;+TokenCode);

  return DONE;
}


// inputコマンド
int cmd_input() throws BasicError{
  int k;
  Variable  var;
  Value val;
  String buf;

  // ファイルから入力
  if( TokenType == DELIMIT &amp;&amp; TokenText.charAt(0)  == &apos;#&apos; ){

    getToken();
    if( TokenType != NUMBER ) assertError( SyntaxError );
    k = (int)TokenValue;
    if( k &lt; 0 || k &gt;= MAX_FILES ) assertError(OutOfRange);
    if( Xfd[k].in == null ) assertError(&quot;ファイルが開いていません(input#)&quot;);
    getToken();
    try{
      for(;;){

            // 変数の場合は入力する
        if( TokenType == VARIABLE ){
          var = _variable( TokenText.toString() );
          val = get_variable_value( var );
          if( (buf = Xfd[k].in.readLine()) == null ) assertError(&quot;ファイルの終わりに到達しました&quot;);

               // 配列変数の場合
          if( var.dimension &gt; 0 ){
                 // 文字列型
            if( val.type == STRING ){
              String[] array = (String[])var.array;
              array[ var.index ]  = new String( buf );
                 }
                 // 数値型
            else{
              double[] array = (double[])var.array;
              array[ var.index ]  = val( buf );
                 }
              }

               // 単純変数の場合
          else{
                 // 文字列型
            if( val.type == STRING ) val.string = new String( buf );
                 // 数値型
            else val.number = val( buf );
              }
           }

            // セパレータ &apos;,&apos; or &apos;;&apos;
        else if( TokenType == DELIMIT &amp;&amp; ( TokenText.charAt(0)  == &apos;,&apos; || TokenText.charAt(0)  == &apos;;&apos; ) ){
          getToken();
           }

            // 上記以外の場合は終了
        else break;
         }
    } catch( IOException ie ){ assertError(&quot;i/o error&quot; ); }
   }

   // コンソールから入力
  else{
    int is_question = 1;
    for(;;){

      // 文字列のときはプロンプト文字列を表示する
      if( TokenType == STRING ){
        disp_puts( TokenText.toString() );_disp();
        getToken();
        }

         // 変数の場合は入力する
      else if( TokenType == VARIABLE ){
        var = _variable( TokenText.toString() );
        val = get_variable_value( var );
        if( is_question != 0 ){ disp_puts( &quot;? &quot; );_disp(); }
        buf = disp_gets();
        buf = buf.substring(0, buf.length()-1 );

        if( !run_basic ) assertError(&quot;Break&quot;);

           // 配列変数の場合
        if( var.dimension &gt; 0 ){
              // 文字列型
          if( val.type == STRING ){
            String[] array = (String[])var.array;
            array[ var.index ]  = new String( buf );
              }
              // 数値型
          else{
            double[] array = (double[])var.array;
            array[ var.index ]  = val( buf );
              }
            }

            // 単純変数の場合
        else{
              // 文字列型
          if( val.type == STRING ) val.string = new String( buf );
              // 数値型
          else val.number = val( buf );
           }
        is_question = 1;
         }

         // このセパレータをつけると&quot;?&quot;のプロンプトを表示する
      else if( TokenType == DELIMIT &amp;&amp; TokenText.charAt(0)  == &apos;,&apos; ){
        is_question = 1;
        getToken();
        }

         // このセパレータをつけると&quot;?&quot;のプロンプトは表示されない
      else if( TokenType == DELIMIT &amp;&amp; TokenText.charAt(0)  == &apos;;&apos; ){
        is_question = 0;
        getToken();
        }

        // 上記以外の場合は終了
      else break;
      }
   }
  return DONE;
}


// gotoコマンド
int cmd_goto() throws BasicError{
  Program p;

  int line = 1;
  if( TokenType != LABEL ) assertError(SyntaxError);

//disp_puts(&quot;cmd_goto:checksum=&quot;+TokenCode+&quot;\n&quot;);_disp();

  if( ( p = serch_label_position( TokenCode, TokenText ) ) == null ) assertError(&quot;ラベルが見つかりません&quot;);
  CurrentProg = p;
  TokenP = 0;
  getToken();
  return DONE;
}


// forコマンド
int cmd_for() throws BasicError{
  Variable var;
  if( ForStackP &gt;= STACK_SIZE ) assertError(&quot;forスタックがオーバーフローしました&quot;);
  if( TokenType != VARIABLE ) assertError( SyntaxError );

  // ループ変数を確保
  var = _variable( TokenText.toString() );
  ForStack[ForStackP] = new FORSF();
  ForStack[ForStackP].var = var;

  // ループ変数に初期値代入
  cmd_let();

  checkToken(&quot;to&quot;);

  // ループ変数上限を得る
  clear_value();
  eval_expression();
  ForStack[ForStackP].limit = get_number();

  // STEP値があるなら代入
  if( TokenText.toString().equals( &quot;step&quot; ) ){
    getToken();
    clear_value();
    eval_expression();
    ForStack[ForStackP].step = get_number();
  }

  // STEP値が省略されていて、なおかつ初期値 &gt;= 終値ならば、STEP値に1を代入
  else if( ForStack[ForStackP].limit &gt;= var.value.number ){
    ForStack[ForStackP].step = 1.0;
  }

  // STEP値が省略されていて、なおかつ初期値 &lt; 終値ならば、STEP値に-1を代入
  else ForStack[ForStackP].step = -1.0;

  // 現在の実行位置をスタックへ保存
  ForStack[ForStackP].program = CurrentProg;
  ForStack[ForStackP].token_p = TokenP;
  ForStackP++;
  return DONE;
}


// nextコマンド
int cmd_next() throws BasicError{
  if( ForStackP &lt;= 0 ) assertError(&quot;for文なしではnext命令を実行できません&quot;);
  ForStackP--;
  if( TokenType == VARIABLE ){
    if( ForStack[ForStackP].var != get_variable( TokenText.toString() ) ) assertError(&quot;next without for&quot;);
    getToken();
  }

  /* STEP値をループ変数へ加える */
  ForStack[ForStackP].var.value.number += ForStack[ForStackP].step;

  // 終了条件を満たさなければループエントリーに戻る
  if( ForStack[ForStackP].step * ( ForStack[ForStackP].var.value.number - ForStack[ForStackP].limit ) &lt;= 0.0 ){
    TokenP = ForStack[ForStackP].token_p;
    CurrentProg = ForStack[ForStackP].program;
    ForStackP++;
    getToken();
  }
  return DONE; 
}


// gosubコマンド
int cmd_gosub() throws BasicError{
  Program p;
  int line = 1;
  if( GosubStackP &gt;= STACK_SIZE ) assertError(&quot;gosubスタックがオーバーフローしました&quot;);
  if( TokenType != LABEL ) assertError( SyntaxError );

//disp_puts(&quot;cmd_gosub:checksum=&quot;+TokenCode+&quot;\n&quot;);_disp();

  if( ( p = serch_label_position( TokenCode, TokenText ) ) == null ) assertError(&quot;ラベルが見つかりません&quot;);
  getToken();
  GosubStack[GosubStackP] = new GOSUBSF();
  GosubStack[GosubStackP].program = CurrentProg;
  GosubStack[GosubStackP].token_p = TokenP;
  GosubStackP++;
  CurrentProg = p;
  TokenP = 0;
  getToken();
  return DONE;
}


// returnコマンド
int cmd_return() throws BasicError{
  if( GosubStackP &lt;= 0 ) assertError(&quot;gosubなしではreturn命令は実行できません&quot;);
  GosubStackP--;
  TokenP = GosubStack[GosubStackP].token_p;
  CurrentProg = GosubStack[GosubStackP].program;
  getToken();
  return DONE;
}


// ifコマンド
int cmd_if() throws BasicError{

  // 論理式が真ならば&quot;thenをチェックしてその次から始める&quot;
  eval_expression();
  if( (int)get_number() != 0 ){
    checkToken(&quot;then&quot;);
    if( TokenType == LABEL ){

//disp_puts(&quot;cmd_if_then:checksum=&quot;+TokenCode+&quot;\n&quot;);_disp();

      Program p = serch_label_position( TokenCode, TokenText );
      if( p == null ) assertError(&quot;ラベルが見つかりません&quot;);
      CurrentProg = p;
      TokenP = 0;
      getToken();
    }
    return DONE;
  }

  // 行のトークンを逐次検索する
  do{
    getToken();

    // &quot;else&quot;があったらそこから始める
    if( TokenText.toString().equals( &quot;else&quot; ) ){
      getToken();
      if( TokenType == LABEL ){

//disp_puts(&quot;cmd_if_else:checksum=&quot;+TokenCode+&quot;\n&quot;);_disp();

        Program p = serch_label_position( TokenCode, TokenText );
        if( p == null ) assertError(&quot;ラベルが見つかりません&quot;);
        CurrentProg = p;
        TokenP = 0;
        getToken();
      }
      return DONE;
    }
  } while( TokenType != EOL );

  // &quot;else&quot;がなかったら完了
  return DONE;
}


// dimコマンド
int cmd_dim() throws BasicError{
  Variable var;  String var_name;
  int[] dim = new int[MAX_DIMENSION];
  int dx=0, nn=0, i=0;
  while(true){
    if( TokenType != VARIABLE ) assertError( SyntaxError );
    var_name = TokenText.toString();

//System.out.println(&quot;var_name=&quot;+var_name);

    getToken();
    checkToken(&quot;(&quot;);
    dx = 0;
    while(true){
      clear_value();
      eval_expression();
      if( dx &gt;= MAX_DIMENSION ) assertError(&quot;配列の次元が大きすぎます&quot;);
      if( ( dim[ dx++ ] = (int)get_number() ) &lt;= 0 ) assertError( OutOfRange );

//System.out.println(&quot;param=&quot;+dim[ dx-1 ]);

      if( TokenType == DELIMIT &amp;&amp; TokenText.charAt(0)  == &apos;)&apos; ) break;
      checkToken(&quot;,&quot;);
    }
    if( get_variable( var_name ) != null ) assertError(&quot;その配列は既に存在しています&quot;);
    var = _variable( var_name );
    var.dimension = dx;

    for( nn = 1, i = 0; i &lt; dx; i++ ) nn *= ( var.dim[ i ] = dim[ i ] + 1 );

//System.out.println(&quot;dim=&quot;+dx+&quot;,num=&quot;+nn);

    // 文字列型配列を初期化
    if( var.value.type == STRING ){
      String[] p = new String[nn];
      var.array = p;
      for( i = 0; i &lt; nn; i++ ){
        p[ i ] = new String(&quot;&quot;);
      }
    }

    // 数値型配列を初期化
    else{
      var.array = new double[nn];
    }

    getToken();
    if( !(TokenType == DELIMIT &amp;&amp; TokenText.charAt(0) == &apos;,&apos;) ) break;
    getToken();
  }

//System.out.println(&quot;token=&quot;+TokenText);

  getToken();
  return DONE;
}


// openコマンド
int cmd_open() throws BasicError{
  int io_flg = 0, i;
  String fname;
  clear_value();
  eval_expression();
  fname = get_string();

   // ネットワークの場合
  if( fname.startsWith(&quot;net:&quot;) ){
    checkToken(&quot;as&quot;);
    checkToken(&quot;#&quot;);
    if( TokenType != NUMBER ) assertError( SyntaxError );
    if( ( i = (int)TokenValue ) &lt; 0 || i &gt;= MAX_FILES ) assertError( OutOfRange );
    getToken();

    if( Xfd[i].sock != null ) assertError(&quot;ファイルは既に開かれています&quot;);
    try{
    try{
      if( fname.length() &lt;= 4 ) assertError(&quot;ネットワークアドレスが不正です&quot;);
      String adrs;
      int port = 80;
      int j = fname.indexOf(&quot;:&quot;, 4 );
      if( j &gt; 4 ){
        adrs = fname.substring( 4, j );
        port = xparseInt( fname.substring(j+1) );
         }
      else adrs = fname.substring( 4, j );
      Xfd[i].sock = new Socket( adrs, port );
      Xfd[i].in0 = Xfd[i].sock.getInputStream();
      Xfd[i].out0= Xfd[i].sock.getOutputStream();
      Xfd[i].in = new BufferedReader(new InputStreamReader(Xfd[i].in0));
      Xfd[i].out = new BufferedWriter(new OutputStreamWriter(Xfd[i].out0));
    } catch( Exception e ){
      if( Xfd[i].sock != null ) Xfd[i].sock.close();
      Xfd[i].sock = null;
      Xfd[i].in =  null;
      Xfd[i].out =  null;
      assertError(&quot;ネットワークに接続できません&quot;);
      }
    } catch( Exception e ){
      Xfd[i].sock = null;
      Xfd[i].in =  null;
      Xfd[i].out =  null;
     }
   }

   // ファイルの場合
  else{
    checkToken(&quot;for&quot;);
    if( TokenText.toString().equals( &quot;input&quot; ) ) io_flg = 0;
    else if( TokenText.toString().equals( &quot;output&quot; ) ) io_flg = 1;
    else assertError( SyntaxError );
    getToken();
    checkToken(&quot;as&quot;);
    checkToken(&quot;#&quot;);
    if( TokenType != NUMBER ) assertError( SyntaxError );
    if( ( i = (int)TokenValue ) &lt; 0 || i &gt;= MAX_FILES ) assertError( OutOfRange );
    getToken();

    if( Xfd[i].in != null || Xfd[i].out != null ) assertError(&quot;ファイルは既に開かれています&quot;);

      // 書きこみモード
    try{
      if( io_flg != 0 ){
        if( (Xfd[i].out = new BufferedWriter( new FileWriter( fname ) )) == null ){
          assertError(&quot;ファイルを開くことができません(write)&quot;);
            }
         }

         // 読み込みモード
      else{
        if( (Xfd[i].in = new BufferedReader( new FileReader( fname ) )) == null ){
          assertError(&quot;ファイルを開くことができません(read)&quot;);
           }
         }
    } catch( IOException e){ assertError(&quot;i/o error&quot;); }
  }
  return DONE;
}


// closeコマンド
int cmd_close() throws BasicError{
  int i;
  if( TokenType == DELIMIT &amp;&amp; TokenText.charAt(0)  == &apos;#&apos; ){
    getToken();
    if( TokenType != NUMBER ) assertError( SyntaxError );
    if( ( i = (int)TokenValue ) &lt; 0 || i &gt;= MAX_FILES ) assertError( OutOfRange );
    try{
      if( Xfd[i].sock != null ){
        Xfd[i].sock.close();
        Xfd[i].sock = null;
        Xfd[i].in = null;
        Xfd[i].out = null;
         }
      else{
        if( Xfd[i].in != null ){
          Xfd[i].in.close();
          Xfd[i].in = null;
            }
        if( Xfd[i].out != null ){
          Xfd[i].out.close();
          Xfd[i].out = null;
            }
         }
    } catch( Exception e){ assertError(&quot;i/o error&quot;); }
    getToken();
   }
  else{
    for( i = 0; i &lt; MAX_FILES; i++ ){
      try{
        if( Xfd[i].sock != null ){
          Xfd[i].sock.close();
          Xfd[i].sock = null;
          Xfd[i].in = null;
          Xfd[i].out = null;
           }
        else{
          if( Xfd[i].in != null ){
            Xfd[i].in.close();
            Xfd[i].in = null;
              }
          if( Xfd[i].out != null ){
            Xfd[i].out.close();
            Xfd[i].out = null;
              }
           }
      } catch( Exception e){ assertError(&quot;i/o error&quot;); }
      }
   }
  return DONE;
}


// clearコマンド
int cmd_clear(){
  clear_value();
  clear_variable();
  ForStackP = 0;
  return DONE;
}


// clsコマンド
int cmd_cls(){
  disp_cls();_disp();
  return DONE;
}


// psetコマンド
int cmd_pset() throws BasicError{
  checkToken(&quot;(&quot;);
  clear_value();
  eval_expression();
  xx0 = (int)get_number();
  checkToken(&quot;,&quot;);
  clear_value();
  eval_expression();
  yy0 = (int)get_number();
  checkToken(&quot;)&quot;);
  if( TokenType == DELIMIT &amp;&amp; TokenText.charAt(0)  == &apos;,&apos; ){
    getToken();
    clear_value();
    eval_expression();
    get_number();
  }
  disp_pset( xx0, yy0 );_disp();
  return DONE;
}


// lineコマンド
int cmd_line() throws BasicError{
  int x1, y1;

  // 開始座標を指定する場合
  if( TokenType == DELIMIT &amp;&amp; TokenText.charAt(0)  == &apos;(&apos; ){
    getToken();
    clear_value();
    eval_expression();
    xx0 = (int)get_number();
    checkToken(&quot;,&quot;);
    clear_value();
    eval_expression();
    yy0 = (int)get_number();
    checkToken(&quot;)&quot;);
  }

  // 開始座標を指定しないときはここから始める
  checkToken(&quot;-&quot;);
  checkToken(&quot;(&quot;);
  clear_value();
  eval_expression();
  x1 = (int)get_number();
  checkToken(&quot;,&quot;);
  clear_value();
  eval_expression();
  y1 = (int)get_number();
  checkToken(&quot;)&quot;);
  if( TokenType == DELIMIT &amp;&amp; TokenText.charAt(0)  == &apos;,&apos; ){
    getToken();
    clear_value();
    eval_expression();
    if( (int)get_number() != 0 ){} else {}
  }
  else {}
  disp_line( xx0, yy0, x1, y1 );_disp();
  xx0 = x1;
  yy0 = y1;
  return DONE;
}


// boxコマンド
int cmd_box() throws BasicError{
  int x1, y1;
  checkToken(&quot;(&quot;);
  clear_value();
  eval_expression();
  xx0 = (int)get_number();
  checkToken(&quot;,&quot;);
  clear_value();
  eval_expression();
  yy0 = (int)get_number();
  checkToken(&quot;)&quot;);
  checkToken(&quot;-&quot;);
  checkToken(&quot;(&quot;);
  clear_value();
  eval_expression();
  x1 = (int)get_number();
  checkToken(&quot;,&quot;);
  clear_value();
  eval_expression();
  y1 = (int)get_number();
  checkToken(&quot;)&quot;);
  if( TokenType == DELIMIT &amp;&amp; TokenText.charAt(0)  == &apos;,&apos; ){
    getToken();
    clear_value();
    eval_expression();
    if( (int)get_number() != 0 ) {} else {}
  }
  else {}
  disp_box( xx0, yy0, x1, y1 );_disp();
  xx0 = x1;
  yy0 = y1;
  return DONE;
}


// boxfコマンド
int cmd_boxf() throws BasicError{
  int x1, y1;
  checkToken(&quot;(&quot;);
  clear_value();
  eval_expression();
  xx0 = (int)get_number();
  checkToken(&quot;,&quot;);
  clear_value();
  eval_expression();
  yy0 = (int)get_number();
  checkToken(&quot;)&quot;);
  checkToken(&quot;-&quot;);
  checkToken(&quot;(&quot;);
  clear_value();
  eval_expression();
  x1 = (int)get_number();
  checkToken(&quot;,&quot;);
  clear_value();
  eval_expression();
  y1 = (int)get_number();
  checkToken(&quot;)&quot;);
  if( TokenType == DELIMIT &amp;&amp; TokenText.charAt(0)  == &apos;,&apos; ){
    getToken();
    clear_value();
    eval_expression();
    if( (int)get_number() != 0 ) {} else{}
  }
  else {}
  disp_boxf( xx0, yy0, x1, y1 );_disp();
  xx0 = x1;
  yy0 = y1;
  return DONE;
}


// circleコマンド
int cmd_circle() throws BasicError{
  int x1, y1;
  checkToken(&quot;(&quot;);
  clear_value();
  eval_expression();
  xx0 = (int)get_number();
  checkToken(&quot;,&quot;);
  clear_value();
  eval_expression();
  yy0 = (int)get_number();
  checkToken(&quot;)&quot;);
  checkToken(&quot;-&quot;);
  checkToken(&quot;(&quot;);
  clear_value();
  eval_expression();
  x1 = (int)get_number();
  checkToken(&quot;,&quot;);
  clear_value();
  eval_expression();
  y1 = (int)get_number();
  checkToken(&quot;)&quot;);
  if( TokenType == DELIMIT &amp;&amp; TokenText.charAt(0)  == &apos;,&apos; ){
    getToken();
    clear_value();
    eval_expression();
    if( (int)get_number() != 0 ) {} else {};
  }
  else {};
  disp_circle( xx0, yy0, x1, y1 );_disp();
  xx0 = x1;
  yy0 = y1;
  return DONE;
}


// circlefコマンド
int cmd_circlef() throws BasicError{
  int x1, y1;
  checkToken(&quot;(&quot;);
  clear_value();
  eval_expression();
  xx0 = (int)get_number();
  checkToken(&quot;,&quot;);
  clear_value();
  eval_expression();
  yy0 = (int)get_number();
  checkToken(&quot;)&quot;);
  checkToken(&quot;-&quot;);
  checkToken(&quot;(&quot;);
  clear_value();
  eval_expression();
  x1 = (int)get_number();
  checkToken(&quot;,&quot;);
  clear_value();
  eval_expression();
  y1 = (int)get_number();
  checkToken(&quot;)&quot;);
  if( TokenType == DELIMIT &amp;&amp; TokenText.charAt(0)  == &apos;,&apos; ){
    getToken();
    clear_value();
    eval_expression();
    if( (int)get_number() != 0 ){} else{}
  }
  else {}
  disp_circlef( xx0, yy0, x1, y1 );_disp();
  xx0 = x1;
  yy0 = y1;
  return DONE;
}


// locateコマンド
int cmd_locate() throws BasicError{
  int x,y;
  clear_value();
  eval_expression();
  x = (int)get_number();
  checkToken(&quot;,&quot;);
  clear_value();
  eval_expression();
  y = (int)get_number();
  disp_locate( x, y );_disp();
  return DONE;
}


// startコマンド
int cmd_start() throws BasicError{
  String cmd;
  clear_value();
  eval_expression();
  cmd = new String( get_string() );
  disp_start( cmd );
  return DONE;
}


// execコマンド
int cmd_exec() throws BasicError{
  String cmd;
  clear_value();
  eval_expression();
  cmd = new String( get_string() );
  disp_exec( cmd );
  return DONE;
}


// waitコマンド
int cmd_wait() throws BasicError{
  int t;
  clear_value();
  eval_expression();
  t = (int)get_number();
  try{
    Thread.sleep( t, 0);
  }catch( InterruptedException e ){}
  return DONE;
}


// imageコマンド
int cmd_image() throws BasicError{
  String fname;
  int x, y;
  checkToken(&quot;(&quot;);
  clear_value();
  eval_expression();
  x = (int)get_number();
  checkToken(&quot;,&quot;);
  clear_value();
  eval_expression();
  y = (int)get_number();
  checkToken(&quot;)&quot;);
  checkToken(&quot;,&quot;);
  clear_value();
  eval_expression();
  fname = new String( get_string() );
  disp_image( x, y, fname );_disp();
  return DONE;
}


// colorコマンド
int cmd_color() throws BasicError{
  int x, y;
  clear_value();
  eval_expression();
  x = (int)get_number();
  if( TokenType == DELIMIT &amp;&amp; TokenText.charAt(0)  == &apos;,&apos; ){
    getToken();
    clear_value();
    eval_expression();
    y = (int)get_number();
    disp_color2( x, y );
  }
  else{
    disp_color1( x );
  }
  return DONE;
}


// screenrコマンド
int cmd_screen() throws BasicError{
  int h, w, f;
  clear_value();
  eval_expression();
  h = (int)get_number();
  checkToken(&quot;,&quot;);
  clear_value();
  eval_expression();
  w = (int)get_number();
  if( TokenType == DELIMIT &amp;&amp; TokenText.charAt(0)  == &apos;,&apos; ){
    getToken();
    clear_value();
    eval_expression();
    f = (int)get_number();
    disp_screen2( h, w, f );
  }
  else{
    disp_screen1( h, w );
  }
  return DONE;
}


// playコマンド
int cmd_play() throws BasicError{
  String fname;
  clear_value();
  eval_expression();
  fname = new String( get_string() );
  disp_play( fname );
  return DONE;
}


// sendコマンド
int cmd_send() throws BasicError{
  int k;
  byte[] x = new byte[1];
  clear_value();
  eval_expression();
  k = (int)get_number();
  checkToken(&quot;,&quot;);
  clear_value();
  eval_expression();
  x[0] = (byte)(int)get_number();
  if( Xfd[k].sock == null ) assertError(&quot;ネットワークに接続されていません(send)&quot;);
  try{
    Xfd[k].out0.write(x);
  } catch( Exception e){ assertError(&quot;書き込みエラー(send)&quot;); }
  return DONE;
}


/* ------------------------------------------ ここから数式解析用の関数　------------------------------------- */


/* 式の処理 */
int eval_expression() throws BasicError{

  // 論理項を解析 */
  eval_lterm();
  for(;;){

    // 論理式は論理項OR論理項OR...
    if( TokenText.toString().equals( &quot;or&quot; ) ){
      getToken();
      eval_lterm();
      eval_or();
    }

    // 上記以外ならば終了
    else{ /* jprintf( &quot;lexp=%lf\n&quot;, (CalcStackP-1)-&gt;data.number);*/ return 0;}
  }

//  return 0;
}


/* 論理項の処理 */
int eval_lterm() throws BasicError{

  // 論理因子を解析
  eval_relation();
  for(;;){

    // 論理項は論理因子AND論理因子AND...
    if( TokenText.toString().equals( &quot;and&quot; ) ){
      getToken();
      eval_relation();
      eval_and();

//jprintf( &quot;lterm=%lf\n&quot;, (CalcStackP-1)-&gt;data.number);

    }

    // 上記以外ならば終了
    else{ /*jprintf( &quot;lterm=%lf\n&quot;, (CalcStackP-1)-&gt;data.number); */ return 0;}
  }

//jprintf( &quot;lterm=%lf\n&quot;, (CalcStackP-1)-&gt;data.number);

//  return 0;
}


/* 関係式の処理 */
int eval_relation() throws BasicError{

  // 式を解析
  eval_aexpression();
  for(;;){

    // 論理因子は 式&gt;=式
    if( TokenText.toString().equals( &quot;&gt;=&quot; ) ){
      getToken();
      eval_aexpression();
      eval_cmp();
      eval_ge();

//jprintf( &quot;ge=%lf\n&quot;, (CalcStackP-1)-&gt;data.number);

    }

    // 論理因子は 式&gt;式
    else if( TokenText.toString().equals( &quot;&gt;&quot; ) ){
      getToken();
      eval_aexpression();
      eval_cmp();
      eval_gt();

//jprintf( &quot;gt=%lf\n&quot;, (CalcStackP-1)-&gt;data.number);

    }

    // 論理因子は 式&lt;=式
    else if( TokenText.toString().equals( &quot;&lt;=&quot; ) ){
      getToken();
      eval_aexpression();
      eval_cmp();
      eval_le();

//jprintf( &quot;le=%lf\n&quot;, (CalcStackP-1)-&gt;data.number);

    }

    // 論理因子は 式&lt;式
    else if( TokenText.toString().equals( &quot;&lt;&quot; ) ){
      getToken();
      eval_aexpression();
      eval_cmp();
      eval_lt();

//jprintf( &quot;lt=%lf\n&quot;, (CalcStackP-1)-&gt;data.number);

    }

    // 論理因子は 式&lt;&gt;式
    else if( TokenText.toString().equals( &quot;&lt;&gt;&quot; ) ){
      getToken();
      eval_aexpression();
      eval_cmp();
      eval_neq();

//jprintf( &quot;ne=%lf\n&quot;, (CalcStackP-1)-&gt;data.number);

    }

    // 論理因子は 式=式
    else if( TokenText.toString().equals( &quot;=&quot; ) ){
      getToken();
      eval_aexpression();
      eval_cmp();
      eval_eq();

//jprintf( &quot;eq=%lf\n&quot;, (CalcStackP-1)-&gt;data.number);

    }

    // 上記以外ならば終了
    else return 0;
  }

//jprintf( &quot;rel=%lf\n&quot;, (CalcStackP-1)-&gt;data.number);

//  return 0;
}


/* 算術式の処理 */
int eval_aexpression() throws BasicError{      

//dprintf(&quot;expression &quot;);

  // 項を解析
  eval_term();

  // 文字列型の場合
  if( value_type() == STRING ){
    for(;;){

      // 式は項+項
      if( TokenType == DELIMIT &amp;&amp; TokenText.charAt(0) == &apos;+&apos; ){
        getToken();
        eval_term();
        eval_concat();
      }
      else return 0;
    }
  }

  // 数値型の場合
  else{
    for(;;){

      // 式は項+項
      if( TokenType == DELIMIT &amp;&amp; TokenText.charAt(0) == &apos;+&apos; ){
        getToken();
        eval_term();
        eval_add();
      }

      // 式は項-項 */
      else if( TokenType == DELIMIT &amp;&amp; TokenText.charAt(0) == &apos;-&apos; ){
        getToken();
        eval_term();
        eval_sub();
      }

      else return 0;
    }
  }
//  return 0;
}


/* 項の処理 */
int eval_term() throws BasicError{      

//dprintf(&quot;term &quot;);

  // 因子を解析
  eval_factor();

  // 乗除算は数値型にのみ適用される
  if( value_type() == NUMBER ){
    for(;;){

      // 項は因子*因子
      if( TokenType == DELIMIT &amp;&amp; TokenText.charAt(0) == &apos;*&apos; ){
        getToken();
        eval_factor();
        eval_mul();
      }

      // 項は因子/因子
      else if( TokenType == DELIMIT &amp;&amp; TokenText.charAt(0) ==&apos;/&apos; ){
        getToken();
        eval_factor();
        eval_div();
      }

      // 項は因子 mod 因子
      else if( TokenText.toString().equals( &quot;mod&quot; ) ){
        getToken();
        eval_factor();
        eval_mod();
      }
      else return 0;
    }
  }
  return 0;
}


/* 因子の処理 */
int eval_factor() throws BasicError{

//dprintf(&quot;factor &quot;);

  // 原子を解析
  eval_atom();

  // べき乗算は数値型にのみ適用される
  if( value_type() == NUMBER ){
    for(;;){

      // 因子は原子^原子
      if( TokenType == DELIMIT &amp;&amp; TokenText.charAt(0) ==&apos;^&apos; ){
        getToken();
        eval_atom();
        eval_power();
      }
      else return 0;
    }
  }
  return 0;
}


/* 原子の処理 */
int eval_atom() throws BasicError{
  int sign = 0;

//dprintf(&quot;atom &quot;);

  /* 原子の前に＋がついている場合(文字列の場合は除外する) */
  if( TokenType == DELIMIT &amp;&amp; TokenText.charAt(0) == &apos;+&apos;){
    getToken();
    sign = 1;
  }

  /* 原子の前に-がついている場合(文字列の場合は除外する) */
  else if( TokenType == DELIMIT &amp;&amp; TokenText.charAt(0)  == &apos;-&apos; ){
    getToken();
    sign = -1;
  }

  /* (式)は原子である */
  if( TokenType == DELIMIT &amp;&amp; TokenText.charAt(0) == &apos;(&apos; ){
    getToken();
    eval_expression();
    checkToken(&quot;)&quot;);
    if( value_type() == STRING ){
      if( sign != 0 ) assertError( TypeMismatch );
    }
    else{
      if( sign == -1 ) put_number( -get_number() );
    }
    return 0;
  }

  /* 数値は原子である*/
  else if( TokenType == NUMBER ){
    put_number( TokenValue );
    getToken();
    if( sign == -1 ) put_number( -get_number() );
    return 0;
  }

  /* 文字列は原子である*/
  else if( TokenType == STRING ){
    put_string( TokenText.toString() );
    getToken();
    if( sign != 0 ) assertError( TypeMismatch );
    return 0;
  }

  /* 関数は原子である */
  else if( TokenType == FUNCTION ){
    doBasicFunction( TokenCode );
    if( value_type() == STRING ){
      if( sign != 0 ) assertError( TypeMismatch );
    }
    else{
      if( sign == -1 ) put_number( -get_number() );
    }
    return 0;
  }

  /* 変数は原子である */
  else if( TokenType == VARIABLE ){
    Variable var = _variable( TokenText.toString() );
    Value val = get_variable_value( var );
    if( val.type == STRING ){
      put_string( val.string );
      if( sign != 0 ) assertError( TypeMismatch );
    }
    else{
      put_number( val.number );
      if( sign == -1 ) put_number( -get_number() );
    }
    return 0;

  }

  else return 0;
}


/* 文字列連結演算 */
int eval_concat() throws BasicError{
  String s1 = get_string();
  String s2 = get_string();
  put_string( s2 + s1 );
  return 0;
}


/* 加算演算 */
int eval_add() throws BasicError{
  put_number( get_number() + get_number() );
  return 0;
}


/* 減算演算 */
int eval_sub() throws BasicError{
  put_number( -get_number() + get_number() );
  return 0;
}


/* 乗算演算 */
int eval_mul() throws BasicError{
  put_number( get_number() * get_number() );
  return 0;
}


/* 除算演算 */
int eval_div() throws BasicError{
  double d1 = get_number();
  double d2 = get_number();
  if( d1 == 0.0 ) assertError(&quot;０で割ろうとしました&quot;);
  put_number( d2 / d1 );
  return 0;
}


/* 除算の余り */
int eval_mod() throws BasicError{
  double d1 = get_number();
  double d2 = get_number();
  if( d1 == 0.0 ) assertError(&quot;０で割ろうとしました&quot;);
  put_number( (double)(  (int)d2 % (int)d1 ) );
  return 0;
}


/* べき乗演算 */
int eval_power() throws BasicError{
  double d1 = get_number();
  double d2 = get_number();
  put_number( Math.pow( d2, d1 ) );
  return 0;
}


/* 論理式 OR 演算 */
int eval_or() throws BasicError{
  put_number( (double)( (int)get_number() | (int)get_number() ) );
  return 0;
}


/* 論理式 AND演算 */
int eval_and() throws BasicError{
  put_number( (double)( (int)get_number() &amp; (int)get_number() ) );
  return 0;
}


/* 比較演算 */
int eval_cmp() throws BasicError{

  // 文字列の場合
  if( value_type() == STRING ){
    String s1 = get_string();
    String s2 = get_string();
    put_number( (double)s2.compareTo( s1 ) );
  }

  // 数値の場合
  else put_number( -get_number() + get_number() );
  return 0;
}


/* &gt;= の確認 */
int eval_ge() throws BasicError{
  put_number( get_number() &gt;= 0.0? 1.0 : 0.0 );
  return 0;
}


/* &gt;  の確認 */
int eval_gt() throws BasicError{
  put_number( get_number() &gt; 0.0? 1.0 : 0.0 );
  return 0;
}


/* &lt;= の確認 */
int eval_le() throws BasicError{
  put_number( get_number() &lt;= 0.0? 1.0 : 0.0 );
  return 0;
}


/* &lt;  の確認 */
int eval_lt() throws BasicError{
  put_number( get_number() &lt; 0.0? 1.0 : 0.0 );
  return 0;
}


/* &lt;&gt; の確認 */
int eval_neq() throws BasicError{
  put_number( get_number() != 0.0? 1.0 : 0.0 );
  return 0;
}


/* =  の確認 */
int eval_eq() throws BasicError{
  put_number( get_number() == 0.0? 1.0 : 0.0 );
  return 0;
}


/* ------------------------------------------ ここからBASICの組込み関数　------------------------------------- */
//
// 文字列を扱う関数では、文法チェックが終わるまではスタックに乗っている値を引き出してはならない
// エラーが起きるとスタックに乗っている文字列は開放されるが、文法チェックが終わる前に引き出してしまうと
// 引き出した文字列は開放されずに残ってしまうことがある
// (数値のみ扱う関数であればいつ引き出しても問題はない)

void doBasicFunction( int func ) throws BasicError{

//Log.d(&quot;doFunc&quot;, &quot;TokenText=&quot;+TokenText+&quot;, Token Type=&quot;+TokenType+&quot; , Code=&quot;+TokenCode);

  switch( func ){
  case  0: func_int();    return;
  case  1: func_abs();    return;
  case  2: func_sqr();    return;
  case  3: func_exp();    return;
  case  4: func_log();    return;
  case  5: func_sin();    return;
  case  6: func_cos();    return;
  case  7: func_tan();    return;
  case  8: func_atn();    return;
  case  9: func_chrs();   return;
  case 10: func_asc();    return;
  case 11: func_mids();   return;
  case 12: func_lefts();  return;
  case 13: func_rights(); return;
  case 14: func_inputs(); return;
  case 15: func_inkeys(); return;
  case 16: func_eof();    return;
  case 17: func_strs();   return;
  case 18: func_val();    return;
  case 19: func_len();    return;
  case 20: func_times();  return;
  case 21: func_dates();  return;
  case 22: func_instr();  return;
  case 23: func_rnd();    return;
  case 24: func_netstat();return;
  case 25: func_recv();   return;
  }
  return;
}


/* int関数 */
int func_int() throws BasicError{
  double a;

//Log.d(&quot;func_int&quot;, &quot;TokenText=&quot;+TokenText+&quot;, Token Type=&quot;+TokenType+&quot; , Code=&quot;+TokenCode);

  getToken();
  checkToken(&quot;(&quot;);
  eval_expression();
  checkToken(&quot;)&quot;);
  a = (double)(int)get_number();
  put_number( a );
  return 0;
}


/* abs関数 */
int func_abs() throws BasicError{
  double a;

//Log.d(&quot;func_abs&quot;, &quot;TokenText=&quot;+TokenText+&quot;, Token Type=&quot;+TokenType+&quot; , Code=&quot;+TokenCode);

  getToken();
  checkToken(&quot;(&quot;);
  eval_expression();
  checkToken(&quot;)&quot;);
  a = get_number();
  if( a&lt; 0 ) a= -a;
  put_number( a );
  return 0;
}


/* sqr関数 */
int func_sqr() throws BasicError{
  double a;

//Log.d(&quot;func_sqr&quot;, &quot;TokenText=&quot;+TokenText+&quot;, Token Type=&quot;+TokenType+&quot; , Code=&quot;+TokenCode);

  getToken();
  checkToken(&quot;(&quot;);
  eval_expression();
  checkToken(&quot;)&quot;);
  a = get_number();
  a = Math.sqrt( a );
  put_number( a );
  return 0;
}


/* exp関数 */
int func_exp() throws BasicError{
  double a;
  getToken();
  checkToken(&quot;(&quot;);
  eval_expression();
  checkToken(&quot;)&quot;);
  a = get_number();
  a = Math.exp( a );
  put_number( a );
  return 0;
}


/* log関数 */
int func_log() throws BasicError{
  double a;
  getToken();
  checkToken(&quot;(&quot;);
  eval_expression();
  checkToken(&quot;)&quot;);
  a = get_number();
  if( a == 0.0 ) assertError(&quot;log関数の引数が０です&quot;);
  a = Math.log( a );
  put_number( a );
  return 0;
}


/* sin関数 */
int func_sin() throws BasicError{
  double a;
  getToken();
  checkToken(&quot;(&quot;);
  eval_expression();
  checkToken(&quot;)&quot;);
  a = get_number();
  a = Math.sin( a );
  put_number( a );
  return 0;
}


/* cos関数 */
int func_cos() throws BasicError{
  double a;
  getToken();
  checkToken(&quot;(&quot;);
  eval_expression();
  checkToken(&quot;)&quot;);
  a = get_number();
  a = Math.cos( a );
  put_number( a );
  return 0;
}


/* tan関数 */
int func_tan() throws BasicError{
  double a;
  getToken();
  checkToken(&quot;(&quot;);
  eval_expression();
  checkToken(&quot;)&quot;);
  a = get_number();
  a = Math.tan( a );
  put_number( a );
  return 0;
}


/* atn関数 */
int func_atn() throws BasicError{
  double a;
  getToken();
  checkToken(&quot;(&quot;);
  eval_expression();
  checkToken(&quot;)&quot;);
  a = get_number();
  a = Math.atan( a );
  put_number( a );
  return 0;
}


/* chr$関数 */
int func_chrs() throws BasicError{
  getToken();
  checkToken(&quot;(&quot;);
  eval_expression();
  checkToken(&quot;)&quot;);
  char ch = (char)(byte)(((int)get_number()) &amp; 0xff);
  put_string( &quot;&quot;+ch );
  return 0;
}


/* asc関数 */
int func_asc() throws BasicError{
  getToken();
  checkToken(&quot;(&quot;);
  eval_expression();
  checkToken(&quot;)&quot;);
  String s = get_string();
  if( s == null || s.length() == 0 ) put_number(0.0);
  else put_number((double)(((int)((byte)(s.charAt(0))))&amp;0xff));
  return 0;
}


/* mid$関数 */
int func_mids() throws BasicError{
  String s;
  int i, j = -1, l;
  getToken();
  checkToken(&quot;(&quot;);
  eval_expression();
  s = get_string();
  checkToken(&quot;,&quot;);
  eval_expression();
  i = (int)get_number() - 1;
  if( TokenType == DELIMIT &amp;&amp; TokenText.charAt(0)  ==&apos;,&apos; ){
    getToken();
    eval_expression();
    j = (int)get_number();
  }
  checkToken(&quot;)&quot;);
  if( j &gt;= 0 ){
    l = s.length();
    j += i;
    if( j &gt; l ) j = l;
    put_string( new String( s.substring( i, j ) ) );
  }
  else put_string( new String( s.substring( i ) ) );
  return 0;
}


/* left$関数 */
int func_lefts() throws BasicError{
  String s;
  int i, l;
  getToken();
  checkToken(&quot;(&quot;);
  eval_expression();
  s = get_string();
  checkToken(&quot;,&quot;);
  eval_expression();
  i = (int)get_number();
  checkToken(&quot;)&quot;);
  l = s.length();
  if( i &gt; l ) i = l;
  put_string( new String( s.substring( 0, i ) ) );
  return 0;
}


/* right$関数 */
int func_rights() throws BasicError{
  String s;
  int i, l;
  getToken();
  checkToken(&quot;(&quot;);
  eval_expression();
  s = get_string();
  checkToken(&quot;,&quot;);
  eval_expression();
  i = (int)get_number();
  checkToken(&quot;)&quot;);
  l = s.length();
  if( i &gt; l ) i = l;
  put_string( new String( s.substring( l - i ) ) );
  return 0;
}


/* input$関数 */
int func_inputs() throws BasicError{
  int c = 0, i, k, m, n;
  StringBuffer s = new StringBuffer(&quot;&quot;);
  getToken();
  checkToken(&quot;(&quot;);
  eval_expression();
  n = (int)get_number();


  // ファイルから指定文字数入力
  if( TokenType == DELIMIT &amp;&amp; TokenText.charAt(0)  == &apos;,&apos; ){
    getToken();
    if( TokenType == DELIMIT &amp;&amp; TokenText.charAt(0)  == &apos;#&apos; ) getToken();
    eval_expression();
    k = (int)get_number();
    checkToken(&quot;)&quot;);
    if( k &lt; 0 || k &gt;= MAX_FILES ) assertError( OutOfRange );
    if( Xfd[k].in == null ) assertError(&quot;ファイルが開いていません(input$)&quot;);

      // ネットワークの場合
    if( Xfd[k].sock != null ){
      try{
        if( (m = Xfd[k].in0.available()) &gt; 0 ){
          if( m &lt; n ) n = m;
          byte cc[] = new byte[n];
          n = Xfd[k].in0.read( cc );
          for( i = 0; i &lt; n; i++ ) s.append( (char)(byte)((int)cc[i] &amp; 0xff) );
           }
      } catch( IOException e){ assertError(&quot;i/o error&quot;); }
      }

      // ファイルの場合
    else{
      try{
        char[] cc = new char[n];
        n = Xfd[k].in.read( cc, 0, n );
        for( i = 0; i &lt; n; i++ ) s.append( cc[i] );
      } catch( IOException e){ assertError(&quot;i/o error&quot;); }
      }
  }

  // コンソールから指定文字数入力
  else{
    checkToken(&quot;)&quot;);
    for( i = 0; i &lt; n; i++ ) s.append( disp_getch() );
  }
  put_string( s.toString() );
  return 0;
}


/* inkey$関数 */
int func_inkeys() throws BasicError{
  String s = &quot;&quot;;
  char c = disp_inkey();
  getToken();
  if( c != &apos;\0&apos; ) s = s +c;
  put_string(s);
  return 0;
}


/* eof関数 */
int func_eof()throws BasicError{
  int c = 0;
  int k;
  getToken();
  checkToken(&quot;(&quot;);
  eval_expression();
  checkToken(&quot;)&quot;);
  k = (int)get_number();
  if( k &lt; 0 || k &gt;= MAX_FILES ) assertError( OutOfRange );
  if( Xfd[k].in == null ) assertError(&quot;ファイルが開いていません(eof)&quot;);

  // ネットワークの場合
  if( Xfd[k].sock != null ){
    try{
      if( Xfd[k].sock.isConnected() ){
        put_number( Xfd[k].in0.available() &gt; 0? 0.0 : 2.0 );
        }
      else put_number(1.0);
    } catch( Exception e){ assertError(&quot;network error&quot;); }
   }

  // ファイルの場合
  else{
    double d = 1.0;
    try{
      d = Xfd[k].in.ready()? 0.0 : 1.0;
    } catch( IOException e){ assertError(&quot;i/o error&quot;); }
    put_number( d );
   }
  return 0;
}


/* str$関数 */
int func_strs() throws BasicError{
  getToken();
  checkToken(&quot;(&quot;);
  eval_expression();
  checkToken(&quot;)&quot;);
  put_string( xstr(get_number()) );
  return 0;
}


/* val関数 */
int func_val() throws BasicError{
  String str;

  getToken();
  checkToken(&quot;(&quot;);
  eval_expression();
  checkToken(&quot;)&quot;);
  str = get_string();
  put_number( val( str ) );
  return 0;
}


/* len関数 */
int func_len() throws BasicError{
  getToken();
  checkToken(&quot;(&quot;);
  eval_expression();
  checkToken(&quot;)&quot;);
  put_number( (double)get_string().length() );
  return 0;
}


/* time$関数 */
int func_times() throws BasicError{
  getToken();
  put_string( disp_time() );
  return 0;
}


/* date$関数 */
int func_dates() throws BasicError{
  getToken();
  put_string( disp_date() );
  return 0;
}


// instr関数
int func_instr() throws BasicError{
  String s, s1, s2;
  int i;
  getToken();
  checkToken(&quot;(&quot;);
  eval_expression();
  checkToken(&quot;,&quot;);
  eval_expression();
  if( TokenType == DELIMIT &amp;&amp; TokenText.charAt(0)  ==&apos;,&apos; ){
    getToken();
    eval_expression();
  }
  else put_number(1.0);
  checkToken(&quot;)&quot;);
  i = (int)get_number() - 1;
  s2 = get_string();
  s1 = get_string();
  i = ( i &gt;= 0 &amp;&amp; i &lt; s1.length() )? s1.indexOf( s2, i )+1 : 0;
  put_number( (double)i );
  return 0;
}


/* 乱数を生成する関数 */
int func_rnd() throws BasicError{
  double a;
  getToken();
  checkToken(&quot;(&quot;);
  eval_expression();
  checkToken(&quot;)&quot;);
  a = get_number();
  a = a * Math.random();
  put_number( a );
  return 0;
}


// ネットワークが使用可能かどうかを返す関数
int func_netstat() throws BasicError{
  getToken();
  put_number( (double)NetStat );
  return 0;
}


/* recv関数 */
int func_recv()throws BasicError{
  int k;
  byte[] x = new byte[1];
  getToken();
  checkToken(&quot;(&quot;);
  eval_expression();
  checkToken(&quot;)&quot;);
  k = (int)get_number();
  if( k &lt; 0 || k &gt;= MAX_FILES ) assertError( OutOfRange );
  if( Xfd[k].sock == null ) assertError(&quot;ネットワークに接続されていません(recv)&quot;);

  try{
    if( !Xfd[k].sock.isConnected() ) assertError(&quot;ネットワークに接続されていません(recv)&quot;);
    if( Xfd[k].in0.available() &gt; 0 ){
      Xfd[k].in0.read(x);
      put_number( ((int)x[0]) &amp; 255 );
      }
    else put_number(-1.0);
  } catch( Exception e){ assertError(&quot;network error&quot;); }

  return 0;
}


/* ------------------------------------------ ここからその他色々な関数　------------------------------------- */

// 計算用スタックを初期化する
void clear_value(){

  // 計算スタックに入っている値を全て取り出す
  while( CalcStackP &gt; 0 ){
    CalcStack[CalcStackP--] = null;
  }
  CalcStackP = 0;
}


// 現在の計算スタックをチェックして整合がとれていなかったらエラーを発生させる
void check_value() throws BasicError{
  if( CalcStackP != 0 ) assertError( &quot;式が不正です&quot;);
}


// 現在の計算スタックの値の型を返す、スタックに値が入っていない場合は0を返す
int value_type(){
  if( CalcStackP == 0 ) return 0;
  return CalcStack[CalcStackP-1].type;
}


// 数値をスタックに置く
void put_number( double num ){
  CalcStack[CalcStackP] = new Value();;
  CalcStack[CalcStackP].type = NUMBER;
  CalcStack[CalcStackP].number  = num;
  CalcStackP++;
}


// 文字列をスタックに置く
void put_string( String str ){

//Log.d(&quot;put_string&quot;, &quot;CalcStack Size=&quot;+CalcStack.length);

  CalcStack[CalcStackP] = new Value();;
  CalcStack[CalcStackP].type = STRING;
  CalcStack[CalcStackP].string  = new String( str );
  CalcStackP++;
}


// 数値をスタックから取りこむ
double get_number() throws BasicError{
  if( value_type() != NUMBER ) assertError( TypeMismatch );
  CalcStackP--;
  return CalcStack[CalcStackP].number;
}


// 文字列をスタックから取りこむ
String get_string() throws BasicError{
  if( value_type() != STRING ) assertError( TypeMismatch );
  CalcStackP--;
  return CalcStack[CalcStackP].string;
}


// 変数の全クリア
void clear_variable(){
  TopVar = EndVar = null;
}


/* 変数名から変数の型を得る */
int var_type( String var_name ){
  return var_name.charAt( var_name.length()-1 ) == &apos;$&apos;? STRING : NUMBER;
}


// 変数名から変数を得る、変数が存在しないときは新しく変数を作る
Variable _variable( String var_name ){
  Variable  var = get_variable( var_name );
  if( var != null ) return var;

  // 変数が見つからなかったら、新しく確保した変数記憶メモリへのポインタを返す 
  var = new Variable();
  var.name = new String( var_name );
  var.dimension = 0;
  var.value = new Value();

  // 文字列変数の場合は空の文字列で初期化、数値変数の場合は0で初期化する
  if( var_type( var_name ) == STRING ){
    var.value.type = STRING;
    var.value.string = new String(&quot;&quot;);
  }
  else{
    var.value.type = NUMBER;
    var.value.number = 0.0;
  }

  // 変数リストに登録する
  if( TopVar == null ) TopVar = var; else  EndVar.next = var;
  EndVar = var;
  var.next = null;
  return var;
}


// 変数名から変数記憶用メモリへのポインタを得る
Variable get_variable( String var_name ){
  Variable  var;

  // 変数を探す
  for( var = TopVar; var != null; var = (Variable)var.next ){
    if( var_name.equals( var.name ) ) return var;
  }

  // 変数が存在しないときはnullを返す
  return null;
}


// 変数の値を得る
Value get_variable_value( Variable var ) throws BasicError{
  Value val = var.value;
  int i, x, index;

  // 単純変数の場合
  if( var.dimension == 0 ){
    getToken();
    return val;
  }

  // 配列変数の場合
  getToken();
  checkToken(&quot;(&quot;);
  eval_expression();
  if( ( index = (int)get_number() ) &lt; 0 || index &gt;= var.dim[0] ) assertError(&quot;配列の添字範囲外です&quot;);
  for( i = 1; i &lt; var.dimension; i++ ){
    checkToken(&quot;,&quot;);
    eval_expression();
    if( ( x = (int)get_number() ) &lt; 0 || x &gt;= var.dim[ i ] ) assertError(&quot;配列の添字範囲外です&quot;);
    index = index * var.dim[ i ] + x;
  }
  checkToken( &quot;)&quot; );
  var.index = index;
  if( val.type == STRING ){
  String[] array = (String[])var.array;
  val.string = array[index];
  }
  else{
  double[] array = (double[])var.array;
  val.number = array[index];
  }
  return val;
}


// 文字列を数値の変換する
double val( String str ) throws BasicError{
  double d = 0.0;

  try{
  if( str.length() == 0 ) return 0.0;
  char c = str.charAt(0);
  if( ( c &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos; ) || c == &apos;.&apos; || c== &apos;+&apos; || c == &apos;-&apos; ) d = xparseDouble( str );
  else if( c == &apos;&amp;&apos; ){
    if( str.length() &lt; 2 ) return 0.0;
    char c2 = str.charAt(1);
    if( c2 == &apos;h&apos; || c2 == &apos;H&apos; ) d = (double)Integer.parseInt( str.substring(2), 16 );
    else if( c2 == &apos;b&apos; || c2 == &apos;B&apos; ) d = (double)Integer.parseInt( str.substring(2), 2 );
    else d = (double)Integer.parseInt( str.substring(1), 8 );
  }
  else d = 0.0;
  }
  catch( Exception e ){ assertError(&quot;数値表現が不正です&quot;);}
  return d;
}

}

boolean isalnum(char c){return ((c&gt;=&apos;a&apos;&amp;&amp;c&lt;=&apos;z&apos;)||(c&gt;=&apos;A&apos;&amp;&amp;c&lt;=&apos;Z&apos;)||(c&gt;=&apos;0&apos;&amp;&amp;c&lt;=&apos;9&apos;)); }
boolean isalpha(char c){return ((c&gt;=&apos;a&apos;&amp;&amp;c&lt;=&apos;z&apos;)||(c&gt;=&apos;A&apos;&amp;&amp;c&lt;=&apos;Z&apos;)); }
boolean isspace(char c){return (c==&apos; &apos;||c==&apos;\t&apos;); }
boolean isdigit(char c){return (c&gt;=&apos;0&apos;&amp;&amp;c&lt;=&apos;9&apos;); }


// エディット画面からロード
void load_edit(){
  String buf = ((SpannableStringBuilder)edit.getText()).toString();
  String line; 
  int pos=0;
  int lbl;
  Program prog;

  ThreadBasic.cmd_new();
  CurrentLineNo = 1;
  while(true){
    if( buf==null ) break;
    pos  = buf.indexOf(&quot;\n&quot;);
    if( pos &lt; 0 ) break;
    line = buf.substring(0,pos); 
    buf = buf.substring(pos+1);
    lbl = checkSum( line );
    if( TopProg == null ){  // プログラムが空の場合
      TopProg = EndProg = new Program( CurrentLineNo++, line+&quot;\r&quot;, lbl, null, null );
      }
    else{
      prog = new Program( CurrentLineNo++, line+&quot;\r&quot;, lbl, EndProg, null );
      EndProg.next = prog;
      EndProg = prog;
     }
   }
}

// エディット画面にセーブ
void save_edit(){
  Program p;
  edit.setText(&quot;&quot;);
  for( p = TopProg; p != null; p = (Program)p.next ){
    String txt = p.text;
    edit.append( txt.substring(0,txt.length()-1) + &quot;\n&quot;);
   }
}


//ラベルのチェックサムを計算する
int checkSum( String s ){
  int i = 0, c = 0, l = s.length();
  while( i &lt; l &amp;&amp; isspace(s.charAt(i)) ) i++;
  if( i &gt;= l-1 || s.charAt(i) != LABEL_HEADER ) return -1;
  i++;
  while( i &lt; l &amp;&amp; (isalnum(s.charAt(i)) || s.charAt(i) == &apos;_&apos;) ){
    c+= (int)(byte)s.charAt(i);
    i++;
  }
  return c;
}


// 数値を文字列に変換する
String xstr( double d ){
  if( d &gt; -1000000 &amp;&amp; d &lt; 1000000 &amp; d == (double)(int)d ) return Integer.toString((int)d);
  else return Double.toString(d);
}


// 文字列を数値に変換する
double xparseDouble( String s ) throws BasicError{
  int i;
  char c;

  for(i=0;i&lt;s.length()&amp;&amp;( ((c=s.charAt(i))&gt;=&apos;0&apos;&amp;&amp;c&lt;=&apos;9&apos;) ||c==&apos;.&apos;||c==&apos;+&apos;||c==&apos;-&apos;||c==&apos;E&apos;||c==&apos;e&apos;); i++ ) ;
  return i == 0? 0.0 : Double.parseDouble(s.substring(0,i));
}


}


// 文字列を整数に変換する
int xparseInt( String s ){
 int n;
 for( n = 0; n &lt; s.length() &amp;&amp; s.charAt(n)&gt;=&apos;0&apos; &amp;&amp; s.charAt(n)&lt;=&apos;9&apos;; n++ ) ;
 if( n &lt; 1 ) return 0;
 return Integer.parseInt( s.substring(0,n) );
}
</codetext>
</codeclip>
<codeclip>
<ID>_C21</ID>
<x0>410</x0>
<y0>264</y0>
<width>483</width>
<height>175</height>
<codetext>// レイアウト設定変数 ( デフォルトでは IS01に適合 )
int for_r=0, for_g=255, for_b=0, bak_r=0, bak_g=0, bak_b=0;
int disp_x = 0, disp_y = 60, disp_width =860, disp_height =340;
int disp_fontsize=24;
int edit_fontsize=20;
int input_x = 0, input_y = 0, input_width = 600, input_height = 60;
int input_fontsize=20;
int enter_x = 600, enter_y = 0, enter_width = 120, enter_height = 60;
int enter_fontsize=20;
int stop_x = 720, stop_y = 0, stop_width = 120, stop_height = 60;
int stop_fontsize=20;
</codetext>
</codeclip>
<operation>
<ID>_O22</ID>
<state1>_SINIT</state1>
<state2>_SINIT</state2>
<x0>61</x0>
<y0>41</y0>
<width>149</width>
<height>67</height>
<inconnectx0>0</inconnectx0>
<inconnecty0>40</inconnecty0>
<outconnectx0>0</outconnectx0>
<outconnecty0>40</outconnecty0>
<inpintext>in()</inpintext>
<inpinx0>0</inpinx0>
<inpiny0>46</inpiny0>
<inpinwidth>40</inpinwidth>
<inpinheight>20</inpinheight>
<outpintext>out()</outpintext>
<outpinx0>98</outpinx0>
<outpiny0>45</outpiny0>
<outpinwidth>40</outpinwidth>
<outpinheight>20</outpinheight>
<inpinlinkcount>1</inpinlinkcount>
<description></description>
<codetext>//レイアウト設定変数を
// 読み込む


String line;
try{

BufferedReader din = new BufferedReader( new FileReader(&quot;/sdcard/basic.ini&quot;));
while( (line=din.readLine()) != null ){
if( line.startsWith(&quot;for_r=&quot;))          for_r=xparseInt(line.substring(6));
if( line.startsWith(&quot;for_g=&quot;))          for_g=xparseInt(line.substring(6));
if( line.startsWith(&quot;for_b=&quot;))          for_b=xparseInt(line.substring(6));
if( line.startsWith(&quot;bak_r=&quot;))          bak_r=xparseInt(line.substring(6));
if( line.startsWith(&quot;bak_g=&quot;))          bak_g=xparseInt(line.substring(6));
if( line.startsWith(&quot;bak_b=&quot;))          bak_b=xparseInt(line.substring(6));
if( line.startsWith(&quot;disp_fontsize=&quot;))  disp_fontsize=xparseInt(line.substring(14));
if( line.startsWith(&quot;edit_fontsize=&quot;))  edit_fontsize=xparseInt(line.substring(14));
if( line.startsWith(&quot;input_fontsize=&quot;)) input_fontsize=xparseInt(line.substring(15));
if( line.startsWith(&quot;enter_fontsize=&quot;)) enter_fontsize=xparseInt(line.substring(15));
if( line.startsWith(&quot;stop_fontsize=&quot;))  stop_fontsize=xparseInt(line.substring(14));
if( line.startsWith(&quot;disp_x=&quot;))         disp_x=xparseInt(line.substring(7));
if( line.startsWith(&quot;disp_y=&quot;))         disp_y=xparseInt(line.substring(7));
if( line.startsWith(&quot;disp_width=&quot;))     disp_width=xparseInt(line.substring(11));
if( line.startsWith(&quot;disp_height=&quot;))    disp_height=xparseInt(line.substring(12));
if( line.startsWith(&quot;input_x=&quot;))        input_x=xparseInt(line.substring(8));
if( line.startsWith(&quot;input_y=&quot;))        input_y=xparseInt(line.substring(8));
if( line.startsWith(&quot;input_width=&quot;))    input_width=xparseInt(line.substring(12));
if( line.startsWith(&quot;input_height=&quot;))   input_height=xparseInt(line.substring(13));
if( line.startsWith(&quot;enter_x=&quot;))        enter_x=xparseInt(line.substring(8));
if( line.startsWith(&quot;enter_y=&quot;))        enter_y=xparseInt(line.substring(8));
if( line.startsWith(&quot;enter_width=&quot;))    enter_width=xparseInt(line.substring(12));
if( line.startsWith(&quot;enter_height=&quot;))   enter_height=xparseInt(line.substring(13));
if( line.startsWith(&quot;stop_x=&quot;))         stop_x=xparseInt(line.substring(7));
if( line.startsWith(&quot;stop_y=&quot;))         stop_y=xparseInt(line.substring(7));
if( line.startsWith(&quot;stop_width=&quot;))     stop_width=xparseInt(line.substring(11));
if( line.startsWith(&quot;stop_height=&quot;))    stop_height=xparseInt(line.substring(12));
}

din.close();
} catch( Exception e ){}
 fontsize = disp_fontsize;
 stepx = fontsize+3;
 stepy = fontsize+3;
 width =  disp_width;
 height = disp_height-stepy;
</codetext>
</operation>
<relation>
<ID>_R23</ID>
<pin1name>_PSTART</pin1name>
<pin2name>_O22</pin2name>
</relation>
<relation>
<ID>_R24</ID>
<pin1name>_O22</pin1name>
<pin2name>_A0(_Pstart)</pin2name>
</relation>
<プロパティ>
<ID>properties</ID>
<LookandFeel>javax.swing.plaf.metal.MetalLookAndFeel</LookandFeel>
<MainWinx0>0</MainWinx0>
<MainWiny0>0</MainWiny0>
<MainWinWidth>1024</MainWinWidth>
<MainWinHeight>740</MainWinHeight>
<MesgWinx0>0</MesgWinx0>
<MesgWiny0>0</MesgWiny0>
<MesgWinWidth>1024</MesgWinWidth>
<MesgWinHeight>745</MesgWinHeight>
<FileWinx0>36</FileWinx0>
<FileWiny0>478</FileWiny0>
<FileWinWidth>578</FileWinWidth>
<FileWinHeight>262</FileWinHeight>
<EditWinx0>347</EditWinx0>
<EditWiny0>0</EditWiny0>
<EditWinWidth>676</EditWinWidth>
<EditWinHeight>541</EditWinHeight>
<PropWinx0>1</PropWinx0>
<PropWiny0>1</PropWiny0>
<PropWinWidth>615</PropWinWidth>
<PropWinHeight>448</PropWinHeight>
<DividerLocation1>2</DividerLocation1>
<DividerLocation2>2</DividerLocation2>
<ToolBarVisible>1</ToolBarVisible>
<ViewSourceAtCompile>0</ViewSourceAtCompile>
<NoSourceCreate>0</NoSourceCreate>
<JavaEditCommand>geany</JavaEditCommand>
<JavaViewCommand></JavaViewCommand>
<HelpCommand>xdg-open ./help/manual.html</HelpCommand>
<ApplicationType>4</ApplicationType>
<CompileCommand0>./compile_java</CompileCommand0>
<RunCommand0>./run_java</RunCommand0>
<GUIDesignerCommand0>java -jar guidsin.jar -java</GUIDesignerCommand0>
<ImportFiles0> import java.awt.*;
 import java.awt.event.*;
 import javax.swing.*;
 import javax.swing.event.*;
 import javax.swing.tree.*;
 import java.io.*;
 import java.net.*;
 import java.util.*;
import java.awt.geom.*;
import java.awt.print.*;
import javax.swing.border.*;
import javax.swing.filechooser.*;
 import javax.swing.*;
 import javax.swing.event.*;
 import javax.swing.tree.*;
 import java.io.*;
 import java.net.*;
 import java.util.*;
import java.awt.image.BufferedImage;
import javax.sound.sampled.*;

class Starter{
  public static void main( String args[] ){
    %AppName% ap = new %AppName%();
    ap.ARGS = args;
    ap.Start();
  }
}
</ImportFiles0>
<ProgramStartupCode0> String[] ARGS;
</ProgramStartupCode0>
<NativeHelpCommand0></NativeHelpCommand0>
<CompileCommand1></CompileCommand1>
<RunCommand1></RunCommand1>
<GUIDesignerCommand1>java -jar guidsin.jar -applet</GUIDesignerCommand1>
<ImportFiles1> import java.awt.*;
 import java.awt.event.*;
 import java.applet.*;
 import javax.swing.*;
 import javax.swing.event.*;
 import javax.swing.tree.*;
 import java.io.*;
 import java.net.*;
 import java.util.*;
 public class javatext extends Applet {
   %AppName% ap;
   public void init() {
     ap = new %AppName%();
     ap.APPLET = this;
     ap.Start();
   }
 }
</ImportFiles1>
<ProgramStartupCode1> Applet APPLET;
</ProgramStartupCode1>
<NativeHelpCommand1></NativeHelpCommand1>
<CompileCommand2></CompileCommand2>
<RunCommand2></RunCommand2>
<GUIDesignerCommand2></GUIDesignerCommand2>
<ImportFiles2>#include &lt;stdio.h&gt;

void Startup();
</ImportFiles2>
<ProgramStartupCode2>int main(){
 Startup();
 %AppName%::Start();
 }
</ProgramStartupCode2>
<NativeHelpCommand2></NativeHelpCommand2>
<CompileCommand3></CompileCommand3>
<RunCommand3></RunCommand3>
<GUIDesignerCommand3>java -jar guidsin.jar -cpp</GUIDesignerCommand3>
<ImportFiles3>#include &lt;stdio.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;math.h&gt;
#include &quot;Ekagen.h&quot;
void Startup();
</ImportFiles3>
<ProgramStartupCode3>void Emain(){
Startup();
%AppName%::Start();
}
</ProgramStartupCode3>
<NativeHelpCommand3></NativeHelpCommand3>
<MoveStep>8</MoveStep>
<ImageEditCommand></ImageEditCommand>
<CompilerFileName>javac.exe</CompilerFileName>
<CompileCommand4>./compile_android A51Basic com example a51basic</CompileCommand4>
<RunCommand4>./run_android Test com example test</RunCommand4>
<GUIDesignerCommand4>java -jar guidsin.jar -android</GUIDesignerCommand4>
<ImportFiles4>package com.example.test;

import android.os.Bundle;
import android.app.Activity;
import android.view.View;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.Paint.Style;
import android.widget.Button;
import android.view.SurfaceHolder;
import android.view.SurfaceHolder.Callback;
import android.view.SurfaceView;
import android.widget.EditText;
import android.text.SpannableStringBuilder;
import android.text.TextWatcher;
import android.text.Editable;
import android.graphics.Matrix;
import android.graphics.Typeface;
import android.graphics.RectF;
import android.graphics.BitmapFactory;
import java.io.*;
 import java.net.*;
import java.util.*;
import java.text.SimpleDateFormat;
import android.media.MediaPlayer;
import android.os.Handler;
import android.content.res.Configuration;
import android.view.LayoutInflater;
import android.view.ViewGroup;
import android.app.Activity;
import android.graphics.Color;

import android.widget.AbsoluteLayout;
import android.widget.*;
import android.view.Gravity;
import android.view.View.OnClickListener;
import java.text.SimpleDateFormat;
import android.hardware.Camera;
import android.net.Uri;
import android.content.Intent;

public class HelloWorld extends Activity {
  public void onCreate(Bundle bundle) {
    super.onCreate(bundle);
    %AppName% ap = new %AppName%();
    ap.ACTIVITY = this;
    ap.Start();
  }
}
</ImportFiles4>
<ProgramStartupCode4>Activity ACTIVITY;
</ProgramStartupCode4>
<NativeHelpCommand4>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    package=&quot;com.example.test&quot;
    android:versionCode=&quot;1&quot;
    android:versionName=&quot;1.0&quot; &gt;

    
    
  &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt; 
  &lt;uses-feature android:name=&quot;android.hardware.camera&quot; /&gt; 
  &lt;uses-feature android:name=&quot;android.hardware.usb.host&quot; /&gt; 
  &lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot;/&gt;
  &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; 
  &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;

  &lt;uses-sdk android:minSdkVersion=&quot;3&quot; android:targetSdkVersion=&quot;21&quot;/&gt;
  
 
    &lt;application android:label=&quot;@string/app_name&quot; &gt;
        &lt;activity
            android:name=&quot;HelloWorld&quot;
            android:label=&quot;@string/app_name&quot; &gt;
            &lt;intent-filter&gt;
                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;

                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
            &lt;/intent-filter&gt;
        &lt;/activity&gt;
    &lt;/application&gt;

&lt;/manifest&gt;
</NativeHelpCommand4>
<HtmlEditCommand></HtmlEditCommand>
<CompileCommand5></CompileCommand5>
<RunCommand5></RunCommand5>
<GUIDesignerCommand5></GUIDesignerCommand5>
<ImportFiles5></ImportFiles5>
<ProgramStartupCode5>gosub @_PSTART
end
</ProgramStartupCode5>
<NativeHelpCommand5></NativeHelpCommand5>
<NoOptimizePin>0</NoOptimizePin>
<CompileCommand6>./compile_c</CompileCommand6>
<RunCommand6>./run_c</RunCommand6>
<GUIDesignerCommand6></GUIDesignerCommand6>
<ImportFiles6>#include &lt;setjmp.h&gt;
#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;math.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;

#include &lt;X11/Xlib.h&gt;
#include &lt;X11/Xutil.h&gt;
#include &lt;X11/Xlocale.h&gt; /* ロケール用ヘッダーファイル */
#include &lt;X11/xpm.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;signal.h&gt;
#include &lt;unistd.h&gt;
#include &lt;termios.h&gt;
#include &lt;errno.h&gt;
</ImportFiles6>
<ProgramStartupCode6>int ARGC; char** ARGV;
int main( int argc, char** argv ){
  ARGC=argc;
  ARGV=argv;
  _PSTART();
}
</ProgramStartupCode6>
<NativeHelpCommand6></NativeHelpCommand6>
<IDF_LocalVariable5>\</IDF_LocalVariable5>
<IDF_LocalVariable7>\</IDF_LocalVariable7>
<CompileCommand7></CompileCommand7>
<RunCommand7></RunCommand7>
<GUIDesignerCommand7></GUIDesignerCommand7>
<ImportFiles7></ImportFiles7>
<ProgramStartupCode7></ProgramStartupCode7>
<NativeHelpCommand7></NativeHelpCommand7>
</プロパティ>
</xobject>
